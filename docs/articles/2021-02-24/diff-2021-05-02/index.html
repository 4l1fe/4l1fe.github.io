<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="utO5yk8RwIXZ-_rnxq_xpMndgtw0MU_VqtE61lNmjsY" />
    <link rel="icon" type="image/png" href="/files/favicon.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css"
          rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl"
          crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <link rel="stylesheet" href="/files/css/style.css">
    <title>ТехнологоблогЪ</title>
</head>
<body>
<nav class="navbar navbar-light bg-white border-bottom border-secondary sticky-top mb-1">
    <div class="container-fluid d-flex justify-content-center ">
            <a class="navbar-brand fs-3" href="/">Технологоблог<b>Ъ</b></a>
            <span class="mx-2"><a class="github-button mx-2" href="https://github.com/4l1fe/4l1fe.github.io/subscription" data-icon="octicon-eye" data-size="large" 
data-show-count="true" aria-label="Watch 4l1fe/4l1fe.github.io on GitHub">Watch</a></span>
            <span class="mx-2"><a class="github-button mx-2" href="https://github.com/4l1fe/4l1fe.github.io" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star 4l1fe/4l1fe.github.io on GitHub">Star</a></span>
    </div>
</nav>
<div class="container">
        <div class="row">
        <div id="content" class="col-lg-9 order-2 order-lg-1">
                        <div class="alert alert-secondary" role="alert">
                <h4 class="alert-heading"></p>Страница отображения <i class="bi bi-file-diff"></i>обновлений</h4>
                <p>
                    <ins>Добавлено</ins>
                    <del>Удалено</del>
                </p>
            </div>
                        <h1>Рассмотрение абстракций и их <ins>взаимосвязей библиотек встраиваемых БД</ins><ins><a id="рассмотрение-абстракций-и-их-взаимосвязей-библиотек-встраиваемых-бд"></a></ins><p><ins><img src="files/main-section.png" alt="main-section"></ins></p> </h1> <p> <del>взаимодействия в библиотеках встраиваемых БД.<a id="рассмотрение-абстракций-и-их-взаимодействия-в-библиотеках-встраиваемых-бд."></a>Прежде всего стоит пояснить, что означает встраиваемая БД и чем они вызывают интерес к рассмотрению, чтобы найти для
этого время.
Встраимаевые БД - предоставляющие интерфейс стандартных операций с данными CRUD и поиска по ним, работающие напрямую с файлом на диске, которые встраиваются в процесс выполнения программы, а не выносятся в отдельный.
</del> Часто возникает желание иметь простейшую архитектуру сервиса или программы, в которой будут отсутствовать избыточные компоненты и межсетевое взаимодействие. Это ощутимо сокращает силы и время на <ins>их</ins> реализацию и поддержку. </p><p> <ins>Чтобы придерживаться такого подхода нужно уметь подбирать </ins><ins><strong>подходящие решения</strong>: технологии, библиотеки, программное обеспечение и т.д.</ins><p><ins>Подбор может быть достаточно прямолинейным - формирование списка подходящих решений по их применяемой области , но, очевидно, что такой список окажется слишком большим и перенасыщенным. Сегодня век информации и потому её объём вокруг нас огромен, который человек физически не способен усвоить даже за всю жизнь. Осознание этой проблемы объема естесвенным образом приводит к формированию интеллектуального подхода - применения ряда <strong>аналитических практик</strong>, приводящих к сокращению кол-ва информации, способной быть усвоенной человеком в сроки, соответствующие решаемой задачи, и сохранению уровня её качества, релевантности. Т.е. подход, сокращающий список подходящих решений без погружения в исходной код до приемлимого и, в конечном итоге, одного решения.</ins></p><ins> </ins><p><ins>В данной статье применяется ряд таких практик, на примере подбора библиотек встраиваемых БД. Как таковая решаемая задача отсутствует, потому необходимости придти к выбору одной из них нету.</ins></p><ins> Пару слов о </ins><ins><strong>встраиваемых БД</strong>: при</ins> </p> <del>При</del> реализации эксперементальных программ удобно иметь файл с подходящей структурой <ul><li> <ins>данных для их сохранения и наличия к нему программного интерфейса базовых операций CRUD, поиска, возможно индексации. Приложение к ним практик  прольет на них больше света по выбору оптимального хранения и оперирования данными.</ins><h2><ins>Цели<a id="цели"></a></ins></h2><ins> </ins><li><ins>Сформировать список библиотек встраиваемых БД для рассмотрения.</ins></li><ins> </ins><li><ins>Сформировать список аналитических практик.</ins></li><ins> Определить</ins> <del>данных, полученных из опыта.
Ряд БД базируется на различных алгоритмах.</del><p><del>Так же надо подчеркнуть, что рассматриваются именно структуры и взаимосвязи, без различных замеров производительности. Интерес именно в</del></p><del> </del><h2><del>Ручная допроверка<a id="ручная-допроверка"></a></del></h2><del> </del><p><del>Используя различные ресурсы(платные и бесплатные) добавить информации о библиотеках(интроспекция кода), напр. график динамики внесения изменений(комитов).</del></p><del> </del><h2><del>Цели.<a id="цели."></a></del></h2><del> </del><p><del><strong>Основной идеей таки является выработака практики общего осмотра устройства, структуры библиотек на примере встраиваемых БД на основе sqlite.</strong></del></p><del> </del><p><del>Процесс пути к пониманию заявленной темы рассмотрения не должен быть сложным,</del></p><del> </del><li><del>Сформировать список рассматриваемых БД.</del></li><del> Рассмотреть</del>  вспомогательные инструменты по анализу исходного кода <h2> <ins>библиотек, лежащих в основе практик.</ins><li><ins>Применить каждую практику отдельно по каждой БД из списка, описав преимущества и недостатки.</ins></li><ins> </ins><li><ins>Сделать заключение.</ins></li><ins> Список БД</ins> <del>библиотек.</del><li><del>Построить диаграммы абстракций.</del></li><del> </del><li><del>Описать преимущества и недостатки по каждой БД.</del></li><del> Список БД для рассмотрения.</del> </h2></li> </ul> <a id="список-бд"></a> <p>В список можно внести огромное кол-во разных вариаций <ins>бибиотек, как упоминалось ранее, но мы сократим</ins> <del>бибиотек: на разных языках, устаревших, в нереализованном состоянии и т.д. Но нужно ограничиться, чтобы сузить</del> его до таковых, которые <del>принесут полезную информацию и</del> могут быть использованы на практике в <ins>будущем(тут конечно каждый сам для себя должен представить, что именно может быть ему полезным, на чем он специализирется или к чему хотел бы приблизиться в своей деятельности). В таких вопросах стоит прислушаться к интуиции.</ins> <del>будущем. А помочь в этом вопросе может личный опыт, знание предметных областей, в которых был он получен, свои идеи, к которым могут быть приложены полученные зания, и, конечно же, интуиция.</del> </p> <p>Помимо прочего, библиотеки должны быть написаны на чистом питоне для чтения исходного кода и техничской возможности анализа вспомогательными инструментами. Основной источник для поиска - </p><p><a href="https://pylint.org/"> <ins>Github.</ins><p><ins>Количество оставим минимальным, т.к. анаоизируемой информации по ним будет суммарно много.</ins></p><ins> </ins><ul><li><ins><a href="https://tinydb.readthedocs.io/en/latest/">tinydb Link: https://tinydb.readthedocs.io/en/latest/ </a></ins></li><ins> </ins><li><ins><a href="https://github.com/RaRe-Technologies/sqlitedict">sqlitedict Link: https://github.com/RaRe-Technologies/sqlitedict </a></ins></li><ins> </ins><li><ins><a href="https://docs.peewee-orm.com/en/latest/peewee/playhouse.html#kv">peewee-kv Link: https://docs.peewee-orm.com/en/latest/peewee/playhouse.html#kv </a></ins></li><ins> </ins></ul><ins> </ins><h2><ins>Список практик<a id="список-практик"></a></ins></h2><ins> </ins><p><ins>Приведем их список, применяемых для получения информации по каждой из библиотек, дающей как бы взгляд со стороны на сложность их внутреннего устройства без погружения в исходный код. Перечисление практик идет в порядке от общего к частному, т.е. самая первая описывает общую картину  наименьшим кол-вом деталей и степенью погружения, при этом больше всех затрагивает высокоуровневые асбтракции, на которых бибилотеки базируются:</ins></p><ins> </ins><ul><li><ins>Построение графа зависимостей модулей.</ins></li><ins> </ins><li><ins>Построение диаграммы  классов.</ins></li><ins> </ins><li><ins>Построение графа вызовов базового </ins><ins><strong>исполняемого сценария</strong> и упрощенной диаграммы их последовательности. Эта практика более близка к реальному использованию библиотеки, т.к. содержит ряд её вызовов, выполнямых повседневно в реальной работе:
</ins><ul><li><ins>Создание БД.</ins></li><ins> </ins><li><ins>Запись данных.</ins></li><ins> </ins><li><ins>Обновление данных.</ins></li><ins> </ins><li><ins>Получение, поиск данных.</ins></li><ins> </ins><li><ins>Удаление записи.</ins></li><ins> </ins></ul><ins> </ins></li><ins> </ins><li><ins>Вычисление цикломатической сложности.</ins></li><ins> </ins></ul><ins> </ins><h2><ins>Вспомогательные инструменты<a id="вспомогательные-инструменты"></a></ins></h2><ins> </ins><p><ins>Перечисление инструментов с общим описанием по каждому, чтобы в дальнейшем было понятно, для чего мы их используем и что от них ожидается.</ins></p><ins> </ins><p><ins>Ресурс, содержащий поддерживаемый <a href="https://github.com/analysis-tools-dev/static-analysis#python">список инструментов Link: https://github.com/analysis-tools-dev/static-analysis#python </a> , по всевозможному анализу кода.</ins></p><ins> </ins><h3><ins>Pyreverse<a id="pyreverse"></a></ins></h3><ins> </ins><ins><a href="https://www.logilab.org/blogentry/6883">https://www.logilab.org/blogentry/6883 Link: https://www.logilab.org/blogentry/6883 </a> https://pylint.org/</ins> <del>Github</del><ul><li><del>4https://dataset.readthedocs.io/en/latest/</del></li><del> </del><li><del>https://tinydb.readthedocs.io/en/latest/</del></li><del> </del><li><del>https://github.com/RaRe-Technologies/sqlitedict</del></li><del> </del><li><del>http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#kv</del></li><del> </del><li><del>http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#dataset</del></li><del> </del><li><del>https://lmdb.readthedocs.io/en/release/</del></li><del> </del><li><del>https://github.com/wbolster/plyvel</del></li><del> </del><li><del>https://github.com/twmht/python-rocksdb <em>based on LevelDB</em></del></li><del> </del><li><del>gdbm</del></li><del> </del><li><del>upscaledb</del></li><del> </del><li><del>http://traildb.io/docs/tutorial/</del></li><del> </del></ul><del> </del><h2><del>Вспомогательные инструменты.<a id="вспомогательные-инструменты."></a></del></h2><del> </del><p><del>Хорошо было бы опереться на результаты работы инструментов по анализу исходного кода, чтобы иметь больше информации для расширения общего взгляда на вещи и работы с предположениями.</del></p><del> </del><p><del>Полученная вспомогательная информация, впрочем, может быть и бесполезной, что выяснится уже при их практическом примененнии.</del></p><del> </del><h3><del>Pyreverse.<a id="pyreverse."></a></del></h3><del> https://www.logilab.org/blogentry/6883
</del> </a></p>  <blockquote><p>Pyreverse analyses Python code and extracts UML class diagrams and package depenndencies.</p> </blockquote> <p> <ins>Утилита является частью пакета <strong>pylint</strong>.</ins> Как видно из цитаты, помогает автоматически построить диаграммы </p><p> <ins>классов. Эти диаграммы дадут нам  видение абстракций, которые содержит БД, и их взаимосвязей. При этом утилита позволяет указывать уровень глубины сканирования исходного кода БД.</ins><h3><ins>Pydeps<a id="pydeps"></a></ins></h3><ins> </ins><p><ins><a href="https://github.com/thebjorn/pydeps">https://github.com/thebjorn/pydeps Link: https://github.com/thebjorn/pydeps </a>.</ins></p><ins> </ins><p><ins>Утилита построения графа зависимостей с генерацией на осное формата <code>.dot</code> программного пакета <a href="http://www.graphviz.org/about/">Graphviz Link: http://www.graphviz.org/about/ </a>. Изображение графа генерируется разными цветами, логика в этом присутствует, но для нас она значения не имеет, поэтому не стоит обращать на это внимание. Графы являются построением наиболее широкой картины того, как БД программно описана, какие верхнеуровневые компоненты содержит и как они взаимосвязаны.</ins></p><ins> </ins><h3><ins>Gprof2dot<a id="gprof2dot"></a></ins></h3><ins> </ins><p><ins>https://github.com/jrfonseca/gprof2dot</ins></p><ins> Утилита строит</ins> <del>классов и импортируемых зависимостей.</del><h3><del>Pycallgraph.<a id="pycallgraph."></a></del></h3><del> </del><p><del>https://pycallgraph.readthedocs.io/en/master/</del></p><del> Понятная альтернатива </del><del><a href="#pyreverse">pyreverse Link: #pyreverse </a>. Строит</del> </p> граф вызовов указанного исполняемого сценария, поэтому необходимо в нем иметь <ins>вызовы оптимального кол-ва </ins><ins><strong>базовых абстракций</strong> библиотеки. Строится из файла формата </ins><ins><code>.pstats</code> стандартной библиотеки </ins><ins><a href="https://docs.python.org/3/library/profile.html#the-stats-class">Stats Link: https://docs.python.org/3/library/profile.html#the-stats-class </a>. В дополнение к ней нужно иметь предустановленный программный пакет </ins><ins><a href="https://graphviz.org/download/#linux">GraphViz Link: https://graphviz.org/download/#linux </a> и в частности утилиту </ins><ins><code>dot</code>.</ins><h3><ins>Radon<a id="radon"></a></ins></h3><ins> </ins><p><ins><a href="https://radon.readthedocs.io/en/latest/">https://radon.readthedocs.io/en/latest/ Link: https://radon.readthedocs.io/en/latest/ </a></ins></p><ins> </ins><p><ins>Утилита сканирует исходный код и выводит показатели следующих характеристик:</ins></p><ins> </ins><ul><li><ins>Cyclomatic Complexity (i.e. McCabe’s Complexity)</ins></li><ins> </ins><li><ins>Halstead metrics</ins></li><ins> </ins></ul><ins> </ins><h3><ins>McCabe<a id="mccabe"></a></ins></h3><ins> </ins><p><ins>https://github.com/pycqa/mccabe</ins></p><ins> </ins><h2><ins>Рассмотрение<a id="рассмотрение"></a></ins></h2><ins> </ins><h3><ins>Построение графа зависимостей<a id="построение-графа-зависимостей"></a></ins></h3><ins> </ins><p><ins>На графах не отображаются модули стандартной бибилиотеки, а только лишь внешние зависимости. Сам сканируемый пакет отображается в именованных прямоугольных рамках, очерчивающих его модули, отображаемые окружностями. Внешние зависимости отображаются в виде изображений папок с их именами.</ins></p><ins> </ins><p><ins>Такой граф дает хорошее визуальное представление</ins></p><ins> </ins><h4><ins>TinyDB<a id="tinydb"></a></ins></h4><ins> </ins><pre><ins><code>pydeps --noshow --cluster --keep-target-cluster --rmprefix tinydb. -T png -o deps.png venv/lib/python3.8/site-packages/tinydb
</code></ins></pre><ins> </ins><p><ins><img src="files/tinydb/deps.png" alt=""></ins></p><ins> </ins><h4><ins>Sqlitedict<a id="sqlitedict"></a></ins></h4><ins> </ins><p><ins><img src="files/sqlitedict/deps.png" alt=""></ins></p><ins> </ins><p><ins>Как видно эта библиотека не имеет никаких зависимостей и даже не скомпанована как пакет, все абстракции содержатся в одном модуле в 550 строк кода и их всего 2, одна из которых основная, верхнеуровневая. Это сразу знак того, что порог входа по изучению нулевой и сложность в использовании ,можно сказать, отсутствует.</ins></p><ins> </ins><p><ins>Казалось бы сказать тут нечего, но это косвенно и обозначает преимущество.</ins></p><ins> </ins><h4><ins>Peewee-kv<a id="peewee-kv"></a></ins></h4><ins> </ins><p><ins>По факту это два модуля пакета <code>playhouse</code> функционал которых реализован на основе библиотеки <strong>peewee</strong>, поэтому они рассматриваются вместе и сканируются единой командой.</ins></p><ins> </ins><pre><ins><code>pydeps --include-missing --max-bacon=1 --noshow --cluster --keep-target-cluster --rmprefix playhouse. -T png -o source-deps.png venv/lib/python3.8/site-packages/playhouse
</code></ins></pre><ins> </ins><p><ins>Команда генерирует взаимосвязи модулей из сканируемого пакета которые нас не интересуют. поэтому следующее изображение отредактировано вручную, а вот <a href="files/peewee-kv/source-deps.png">ссылка на исходное Link: files/peewee-kv/source-deps.png </a> для сравнения.</ins></p><ins> </ins><p><ins><img src="files/peewee-kv/edited-deps.png" alt=""></ins></p><ins> </ins><p><ins>Как видно <code>kv</code> содержит меньше связей по сравнению с <code>dataset</code>.</ins></p><ins> </ins><h3><ins>Построение диаграммы классов<a id="построение-диаграммы-классов"></a></ins></h3><ins> </ins><p><ins>В каждой секции будет присутствовать ссылка на исходную диаграмму - большое по размеру изображение, включающее все что нужно и нет, и изображение ограниченное только базовыми абстракциями библиотеки.</ins></p><ins> </ins><p><ins>В каждой из секций будет приведено два изображения: <strong>полное</strong> по ссылке и <strong>отредактированное</strong> встроенное, отображающее интересующую нас суть.</ins></p><ins> </ins><h4><ins>TinyDB<a id="tinydb"></a></ins></h4><ins> </ins><pre><ins><code>pyreverse -o png venv/lib/python3.8/site-packages/tinydb
</code></ins></pre><ins> </ins><p><ins><img src="files/tinydb/classes.png" alt=""></ins></p><ins> </ins><p><ins>Достаточно много классов, потому можно предположить, что библиотека предоствляет возможности расширения своими кастомными классами, собственно на это указывают <strong>generalization</strong> связи, например <code>Storage &lt;- MemoryStorage</code>.</ins></p><ins> </ins><p><ins>Семантичные имена, такие как <code>Middleware, Query, JsonStorage</code>, дают понимание о том что есть некий общий слой обработки, какой-то язык запросов, ну и хранение в конкретном формате <code>json</code>.</ins></p><ins> </ins><p><ins>Связи у классов <code>Middleware, Query</code> с иными в диаграмме полностью отсутствуют, а значит для их фактического установления необходимо погружаться в код , либо документацию, что уже требует небольших дополнительных усилий, но небольших, потому что библиотека самодостаточно и все содержит в себе.</ins></p><ins> </ins><h4><ins>Sqlitedict<a id="sqlitedict"></a></ins></h4><ins> </ins><p><ins><a href="files/sqlitedict/source-classes.png">Полное отображение Link: files/sqlitedict/source-classes.png </a>.</ins></p><ins> </ins><pre><ins><code>pyreverse -o png venv/lib/python3.8/site-packages/sqlitedict.py
</code></ins></pre><ins> </ins><p><ins><img src="files/sqlitedict/classes.png" alt=""></ins></p><ins> </ins><p><ins>Выглядит минималистично, прямо сейчас открывай код и читай, нет нужды в чтении документации. Напрямую работа в с БД происходит только лишь через <code>SqliteDict</code>, вторая добавляет способность многопоточности и не подразумевает прямых обращений из исполняемого сценария.</ins></p><ins> </ins><h4><ins>Peewee-kv<a id="peewee-kv"></a></ins></h4><ins> </ins><p><ins><a href="files/peewee-kv/source-classes.png">Полное отображение Link: files/peewee-kv/source-classes.png </a>.</ins></p><ins> </ins><pre><ins><code>pyreverse -o png venv/lib/python3.8/site-packages/playhouse/kv.py
</code></ins></pre><ins> </ins><p><ins><img src="files/peewee-kv/classes.png" alt=""></ins></p> <del>вызовы, покрывающие по нисходящей(от высокоуровневых выовов к низкоуровневым) наибольшую часть абстракций библиотеки.</del><h3><del>Sourcegraph.<a id="sourcegraph."></a></del></h3><del> </del><p><del>https://about.sourcegraph.com/</del></p><del> </del><p><del>Не нашел наглядных примеров для понимания, что этот сервис может предоставить.</del></p><del> </del><h3><del>Prospector.<a id="prospector."></a></del></h3><del> </del><p><del>https://github.com/PyCQA/prospector</del></p><del> </del><p><del>Некий аггрегатор анализирующих инструментов. Может дать информацию сразу по многим аспектом. Теоретически выявляет места, на которые сразу стоит обратить внимание.</del></p><del> </del><p><del>Полезно использовать при сравнении полученной информации по множеству библиотек в случае подбора более подходящей под решение.</del></p><del> </del><h3><del>Pylama.<a id="pylama."></a></del></h3><del> </del><p><del>https://github.com/klen/pylama</del></p><del> </del><p><del>Альтернатива <a href="#prospector">prospector Link: #prospector </a> менее популярная , судя по показателям в Гитхабе.</del></p><del> </del><h3><del>Vulture.<a id="vulture."></a></del></h3><del> </del><p><del>https://github.com/jendrikseipp/vulture</del></p><del> </del><p><del>Динамический поисковик неиспользуемого кода. Полезно для видения, насколько исходный код бибилиотеки находится в актуальном состоянии, в каких углах запылилась.</del></p><del> </del><h3><del>Поддерживаемый список библиотек по анализу кода.<a id="поддерживаемый-список-библиотек-по-анализу-кода."></a></del></h3><del> </del><p><del>https://github.com/analysis-tools-dev/static-analysis#python</del></p><del> </del><p><del>Может осветить еще потенциальнополезные утилиты или нет. Надо выделить на это отдельное время.</del></p><del> </del><h3><del>Pydeps<a id="pydeps"></a></del></h3><del> </del><p><del>Альтернатива использования  <strong>pyreverse</strong></del></p><del> </del><p><del>https://github.com/thebjorn/pydeps</del></p><del> </del><h3><del>Radon<a id="radon"></a></del></h3><del> </del><p><del>https://radon.readthedocs.io/en/latest/</del></p><del> </del><h2><del>Общая практика рассмотрения.<a id="общая-практика-рассмотрения."></a></del></h2><del> </del><p><del>Список единых операций, выполняемых для получения информации о каждой из библиотек, дающей как бы взгляд со стороны на сложность их внутреннего устройства без погружения в исходный код. Полученные результаты вынесены в отдельную секцию.</del></p><del> </del><li><del>Построение диаграмм взаимосвязей модулей и абстракций.</del></li>  <h3>Построение графа вызовов<h4> <ins><a id="построение-графа-вызовов"></a></ins><p><ins>Граф базового исполняемого сценария, описанного ранее, будет строиться следующими командами исполненными последовательно для каждого отдельно.</ins></p><ins> </ins><pre><ins><code>$ python -m cProfile -s nfl -o basic-scenario.pstats basic-scenario.py
$ gprof2dot -f pstats basic-scenario.pstats -o basic-scenario.dot
$ dot -Tpng basic-scenario.dot -o basic-scenario.png
</code></ins></pre><ins> </ins><p><ins>Код приведенный в каждой секции ниже содержится в <code>basic-scenario.py</code> , который и надо просканировать командами выше. Все вызовы из него должны интуитивно читаться на изображении без каких-либо усилий.</ins></p><ins> </ins><p><ins>Как и в части диаграмм классов будет присутствовать полное и отредактирование изображения графов.</ins></p><ins> TinyDB</ins> </h4></h3> <del>базового сценария и упрощенной диаграммы их последовательности:
</del><ul><li><del>Создание БД.</del></li><del> </del><li><del>Запись данных.</del></li><del> </del><li><del>Обновление данных.</del></li><del> </del><li><del>Получение, поиск данных.</del></li><del> </del></ul><del> </del><h2><del>Рассмотрение.<a id="рассмотрение."></a></del></h2><del> </del><p><del>В общем, приминимо к каждой библиотеке будут выполнены идентичиные шаги анализа, а вот сопровождающее описание будет частным и самым ценным в проделанной работе.</del></p><del> </del><p><del>Шаги:</del></p><del> </del><ul><li><del>prospector</del></li><del> </del><li><del>Граф вызовов pycallgraph к минимальному использованию БД, семантически-общий сниппет кода.</del></li><del> </del><li><del></del></li></ul><del> </del><h3><del>Dataset 1.4.1<a id="dataset-1.4.1"></a></del></h3><del> </del><p><del>Надстройка SQLAlchemy, что сразу говорит о многообразии абстракций, состоящих из двух слоёв: <strong>SQLAlchemy ORM, SQLAlchemy Core</strong>.</del></p><del> </del><p><del>Сама надстройка объявляет 2 основные абстракции: <strong>Database, Table</strong> описанных в 2х модулях суммарно на 1025 строк
кода, имея, тем самым, низкий порог входа понимания их диаграммы взаимодействия.</del></p><del> </del><pre><del><code>prospector --with-tool vulture
</code></del></pre><del> </del><blockquote><p><del><a href="files/dataset/prospector.txt">Анализ Link: files/dataset/prospector.txt </a> кода.</del></p><del> </del></blockquote><del> </del><pre><del><code>from pycallgraph import PyCallGraph
from pycallgraph.output import GraphvizOutput

import dataset


with PyCallGraph(output=GraphvizOutput()):
    db = dataset.connect('sqlite:///:memory:')
    table = db['sometable']
    table.insert(dict(name='John Doe', age=37))
    table.insert(dict(name='Jane Doe', age=34, gender='female'))
    john = table.find_one(name='John Doe')
</code></del></pre><del> </del><blockquote><p><del><a href="files/dataset/pycallgraph.png">Граф Link: files/dataset/pycallgraph.png </a> вызовов. Содержит очень большой набор вызовов и множества модулей.</del></p><del> </del></blockquote><del> </del><pre><del><code>pyreverse  -AS -f ALL -o png  venv/lib/python3.7/site-packages/dataset
</code></del></pre><del> </del><blockquote><p><del>Полученная <a href="files/dataset/classes.png">диаграмма классов Link: files/dataset/classes.png </a>. Очень громоздкая диаграмма с большим кол-вом классов и взаимосвязей. Сказывается базирование на sqlalchemy.</del></p><del> </del><p><del><a href="files/dataset/packages.png">Диаграмма связей модулей Link: files/dataset/packages.png </a>.</del></p><del> </del></blockquote><del> </del><h3><del>TinyDB 4.3.0<a id="tinydb-4.3.0"></a></del></h3><del> </del><pre><del><code>prospector --with-tool vulture
</code></del></pre><del> </del><blockquote><p><del><a href="files/tinydb/prospector.txt">Анализ Link: files/tinydb/prospector.txt </a> кода.</del></p><del> </del></blockquote><del> from pycallgraph import PyCallGraph
from pycallgraph.output import GraphvizOutput

</del> <a id="tinydb"></a> <pre><code>from tinydb import TinyDB, Query

 <ins>def main():
    db = TinyDB('test.tinydb')
    table = db.table(TinyDB.default_table_name)
    r1 = table.insert({'name': 'John', 'age': 22})
    r2 = table.insert({'name': 'Van', 'car': 'volvo'})
   </ins> <del>from tinydb.storages import MemoryStorage


with PyCallGraph(output=GraphvizOutput()):
    db = TinyDB(storage=MemoryStorage)
   </del> User = Query()
    <ins>upd = table.update({'car': 'bmw'}, User.age == 22)
    records = table.search(User.name == 'John')
    table.remove(User.name == 'Van')

if __name__ == '__main__':
    main()
</ins><p><ins><a href="files/tinydb/basic-scenario.png">Полный граф Link: files/tinydb/basic-scenario.png </a></ins></p><ins> </ins><p><ins><img src="files/tinydb/basic-scenario-edited.png" alt=""></ins></p><ins> </ins><p><ins>Видно как операции объекта <code>table</code> обращаются к объекту <code>storage</code> и обращение к нему в свою очередь объекта <code>database</code>. Сценарий очень хорошо читается на самом изображении, вплоть до сброса данных на диск, но сопоставив его с изображением диаграммы классов появляется неясность из-за отсутствия абстракций <code>Middleware, Document, Query</code>. Понятно, что они где-то неявно учавствует(как минимум <code>Document, Query</code>) и логически можно установить это место, но хотелось бы это просто видеть.</ins></p><ins> </ins><h4><ins>Sqlitedict<a id="sqlitedict"></a></ins></h4><ins> </ins><pre><ins><code>from sqlitedict import SqliteDict

def main():
    db = SqliteDict('test.sqlite', autocommit=True)
    db['user1'] = {'name': 'John', 'age': 22}
    db['user2'] = {'name': 'Van', 'car': 'volvo'}
    db['user1']['car'] = 'bmw'
    u = db['user1']
    del db['user2']

if __name__ == '__main__':
    main()
</code></ins></pre><ins> </ins><p><ins><a href="files/sqlitedict/basic-scenario.png">Полный граф Link: files/sqlitedict/basic-scenario.png </a></ins></p><ins> </ins><p><ins><img src="files/sqlitedict/basic-scenario-edited.png" alt=""></ins></p><ins> </ins><p><ins>Явным отличием от предшественника является наличие объекта синхронизации потоков <code>queue</code>, т.к. вообще все вызовы <code>execute</code> производятся классом <code>SqliteMultithread</code> это мы знаем из диаграммы класса библиотеки.</ins></p><ins> </ins><h4><ins>Peewee-kv<a id="peewee-kv"></a></ins></h4><ins> </ins><pre><ins><code>from playhouse.kv import KeyValue

def main():
    db = KeyValue()
    db['user1'] = {'name': 'John', 'age': 22}
    db['user2'] = {'name': 'Van', 'car': 'volvo'}
    db['user1']['car'] = 'bmw'
    records = db[db.key == 'user1']
    del db['user2']
    
if __name__ == '__main__':
    main()
</code></ins></pre><ins> </ins><p><ins><a href="files/peewee-kv/basic-scenario.png">Полный граф Link: files/peewee-kv/basic-scenario.png </a></ins></p><ins> </ins><p><ins><img src="files/peewee-kv/basic-scenario-edited.png" alt=""></ins></p><ins> </ins><p><ins>Изображение сразу же демонстрирует большую глубину дерева по сравнению с <strong>tinydb, sqlitedict</strong> и малую степень участия в нем верхнеуровневой абстракции <code>kv</code>.</ins></p><ins> </ins><h3><ins>Цикломатическая сложность<a id="цикломатическая-сложность"></a></ins></h3><ins> </ins><p><ins>Для нахождения <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">цикломатической сложности Link: https://en.wikipedia.org/wiki/Cyclomatic_complexity </a> воспользуемся утилитой <strong>radon</strong> и произведем нижеследующий вызов для каждой библиотеки.</ins></p><ins> </ins><pre><ins><code>radon cc -s --md venv/lib/python3.8/site-packages/tinydb
</code></ins></pre><ins> </ins><p><ins>Формат <code>md</code> взят для прощей читаемости и дальнейшей обработки полученных данных. Полученные данные <a href="files/tinydb/cc.md">tiny.md Link: files/tinydb/cc.md </a>, <a href="files/sqlitedict/cc.md">sqlitedict.md Link: files/sqlitedict/cc.md </a>, <a href="files/peewee-kv/cc.md">kv.md Link: files/peewee-kv/cc.md </a>.</ins></p><ins> </ins><p><ins>Впринципе, данные таблицы уже показывают нам какая библиотека состоит из большего кол-ва проходимых путей управляющим потоком и какое число сложности у каждого из них, чтобы опять же, не углубляясь в детали, увидеть рассматриваемую характеристику. Но такое списочночисловое представление не настолько наглядно при сравнении одновоременно 3х объектов. Для этого надо слить все таблицы в один файл и, прокручивая их, сравнивать количественнокачественные показатели, аналитически их сопоставляя.</ins></p><ins> </ins><p><ins>Для большего удобства восприятия полученных значений мы можем построить график с цветовой передачей вышеописанных характеристик на основе табличных файлов с помощью <strong>matplotlib, numpy</strong>. По задумке глубина цвета сразу интуитивно выделит места, требующие внимания.</ins></p><ins> </ins><p><ins>Код построения графика <a href="files/cc_ranks.py">cc_ranks.py Link: files/cc_ranks.py </a> и само изображение.</ins></p><ins> </ins><p><ins><img src="files/CC-chart.png" alt=""></ins></p><ins> </ins><p><ins>Как и было задумано, изображение демонстрирует показатели, как объем и цветовой тон, т.е. мы видим без аналитического сопоставления, что по количественному показателю(количество ячеек) доминирует <strong>TinyDB</strong>, а по качественному(глубокие фиолетовые тона) <strong>Sqlitedict</strong>. Цветовая шкала справа имеет максимальное значение <code>20</code> как наибольшую сложность лишь для адаптации к нашим имеющимся значениям, в то время как согласно <a href="https://radon.readthedocs.io/en/latest/commandline.html#the-cc-command">заявленным категориям Link: https://radon.readthedocs.io/en/latest/commandline.html#the-cc-command </a> оно должно быть <code>41+</code>.</ins></p><ins> </ins><p><ins>В дополнение мы можем вывести самый сложный метод в <strong>Sqlitedict</strong> и построить его граф потока управления следующими командами:</ins></p><ins> </ins><pre><ins><code>python -m mccabe -d venv/lib/python3.8/site-packages/sqlitedict.py &gt; mccabe.dot
dot -Tpng mccabe.dot -o mccabe.png
</code></ins></pre><ins> </ins><p><ins>Полученный граф <a href="files/sqlitedict/mccabe.png">mccabe.png Link: files/sqlitedict/mccabe.png </a> , в котором визуально заметен метод <code>SqliteMultithread.run</code>.</ins></p><ins> </ins><h3><ins>Halstead замеры<a id="halstead-замеры"></a></ins></h3><ins> </ins><h2><ins>Заключение<a id="заключение"></a></ins></h2> <del>db.insert({'name': 'John', 'age': 22})
    db.insert({'name': 'Van', 'car': 'volvo'})
    db.search(User.name == 'Van')
</del><blockquote><p><del><a href="files/tinydb/pycallgraph.png">Граф Link: files/tinydb/pycallgraph.png </a> вызовов. Содержит крошечный набор вызовов.</del></p><del> </del></blockquote><del> </del><pre><del><code>pyreverse  -AS -f ALL -o png  venv/lib/python3.7/site-packages/tinydb
</code></del></pre><del> </del><blockquote><p><del>Полученная <a href="files/tinydb/classes.png">диаграмма классов Link: files/tinydb/classes.png </a>.</del></p><del> </del><p><del><a href="files/tinydb/packages.png">Диаграмма связей модулей Link: files/tinydb/packages.png </a>.</del></p><del> </del></blockquote><del> </del><h3><del>Sqlitedict 1.7.0<a id="sqlitedict-1.7.0"></a></del></h3><del> </del><ul><li><p><del>Минимализм, выраженный 1м модулем из 550 строк кода.</del></p><del> </del></li><del> </del><li><p><del>Всего <u>2 абстракции и 1 основная</u>, т.е. для взаимодействия с данными используется <strong>SqliteDict</strong>, предоставляющий  соответствующий интерфейс, который обращается к кастомному <strong>SqliteMultithread</strong>. Этот объект уже напрямую выполняет операции в БД.</del></p><del> </del><pre><del><code class="language-mermaid">sequenceDiagram
participant main
participant SD as calendar:SqliteDict
participant SMT as connection:SqliteMultithread
main-&gt;&gt;+SD: calendar["today"]
SD-&gt;&gt;+SMT: connection.execute(sql)
Note over SMT: select value from calendar where key=today
SMT--&gt;&gt;-SD: "day off"
SD--&gt;&gt;-main: "day off"
</code></del></pre><del> </del></li><del> </del><li><p><del>На уровне БД схема таблиц(они же словари) организована наипростейшим образом без возможности кастомизации. <strong>Ключ</strong> объявлен строковым, а <strong>значение</strong> бинарным типами. Таким образом на уровне питона <u>неполностью эмулируются возможности словаря</u>.</del></p><del> </del><pre><del><code>complex_discount = SqliteDict('db.sqlite')
complex_discount[('pencil', 'case', 'eraser')] = 15

sqlite3.InterfaceError: Error binding parameter 0 - probably unsupported type.
</code></del></pre><del> </del></li><del> </del><li><p><del>Автогенерируемый <strong>индекс</strong> по ключу.</del></p><del> </del></li><del> </del><li><p><del>Поддержка кастомной сериализации значений</del></p><del> </del><pre><del><code>rss = SqliteDict('db.sqlite', encode=xml_encode, decode=xml_decode)
</code></del></pre><del> </del></li><del> </del><li><p><del>Поддержка многопоточности.</del></p><del> </del><p><del>Следует отметить, что в данной реализации объект-словарь необходимо разделять между потоками.</del></p><del> </del><pre><del><code>def job(job_results):
	k, v = fetch()
	job_results[k] = v

job_results = SqliteDict('db.sqlite')

t1 = Thread(target=job, args=(job_results, ))
t2 = Thread(target=job, args=(job_results, ))
</code></del></pre><del> </del></li><del> </del><li><p><del>Зачем-то оставлен режим создания БД в памяти <code>:memory:</code>. Было бы логичным его убрать для позиционируемой персистентности  словаря.</del></p><del> </del></li><del> </del><li><p><del>Хороший кандидат для быстрого старта и фокусировки на логике работы с данными, но остается неясность в том, как будет вести себя объект-словарь при различных вариациях параметров <code>autocommit, journal_mode</code>.</del></p><del> </del></li><del> </del></ul><del> </del><h2><del>Результаты применения общей практики.<a id="результаты-применения-общей-практики."></a></del></h2><del> </del><h3><del>Dataset.<a id="dataset."></a></del></h3><del> </del><h4><del>Диаграммы.<a id="диаграммы."></a></del></h4><del> </del><p><del><img src="files/dataset/packages.png" alt="packages"></del></p><del> </del><p><del><img src="files/dataset/classes.png" alt="classes"></del></p><del> </del><h3><del>TinyDB.<a id="tinydb."></a></del></h3><del> </del><p><del><img src="files/tinydb/packages.png" alt="packages"></del></p><del> </del><p><del><img src="files/tinydb/classes.png" alt="classes"></del></p><del> </del><h3><del>Sqlitedict<a id="sqlitedict"></a></del></h3><del> </del><p><del><img src="files/sqlitedict/classes.png" alt="classes"></del></p> </code></pre> 
        </div>
        <div id="toc" class="col-lg-3 order-1 order-lg-2">
            <ul><li><a href="#цели">Цели</a></li><li><a href="#список-бд">Список БД</a></li><li><a href="#список-практик">Список практик</a></li><li><a href="#вспомогательные-инструменты">Вспомогательные инструменты</a><ul><li><a href="#pyreverse">Pyreverse</a></li><li><a href="#pydeps">Pydeps</a></li><li><a href="#gprof2dot">Gprof2dot</a></li><li><a href="#radon">Radon</a></li><li><a href="#mccabe">McCabe</a></li></ul></li><li><a href="#рассмотрение">Рассмотрение</a><ul><li><a href="#построение-графа-зависимостей">Построение графа зависимостей</a></li><li><a href="#построение-диаграммы-классов">Построение диаграммы классов</a></li><li><a href="#построение-графа-вызовов">Построение графа вызовов</a></li><li><a href="#цикломатическая-сложность">Цикломатическая сложность</a></li><li><a href="#halstead-замеры">Halstead замеры</a></li></ul></li><li><a href="#заключение">Заключение</a></li></ul>
        </div>
    </div>
    </div>

<script src="https://buttons.github.io/buttons.js"></script>
</body>
</html>