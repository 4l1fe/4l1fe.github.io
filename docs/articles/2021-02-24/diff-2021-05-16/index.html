<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="utO5yk8RwIXZ-_rnxq_xpMndgtw0MU_VqtE61lNmjsY" />
    <link rel="icon" type="image/png" href="/files/favicon.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css"
          rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl"
          crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">
<!--    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />-->
    <link rel="stylesheet" href="/files/css/style.css">
    <script src="https://code.iconify.design/1/1.0.7/iconify.min.js"></script>
    <title>ТехнологоблогЪ</title>
</head>
<body>
<nav class="navbar navbar-light bg-white border-bottom border-secondary sticky-top mb-1">
    <div class="container-fluid d-flex justify-content-center ">
            <a class="navbar-brand fs-3" href="/">Технологоблог<b>Ъ</b></a>
            <span class="mx-2"><a class="github-button mx-2" href="https://github.com/4l1fe/4l1fe.github.io/subscription" data-icon="octicon-eye" data-size="large" 
data-show-count="true" aria-label="Watch 4l1fe/4l1fe.github.io on GitHub">Watch</a></span>
            <span class="mx-2"><a class="github-button mx-2" href="https://github.com/4l1fe/4l1fe.github.io" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star 4l1fe/4l1fe.github.io on GitHub">Star</a></span>
    </div>
</nav>
<div class="container">
        <div class="row">
        <div id="content" class="col-lg-9 order-2 order-lg-1">
                        <div class="alert alert-secondary" role="alert">
                <h4 class="alert-heading"></p>Страница отображения <i class="bi bi-file-diff"></i>обновлений</h4>
                <p>
                    <ins>Добавлено</ins>
                    <del>Удалено</del>
                </p>
            </div>
                        <div> <h1><ins>Рассмотрение абстракций, их взаимосвязей и сложности библиотек встраиваемых БД <a id="рассмотрение-абстракций,-их-взаимосвязей-и-сложности-библиотек-встраиваемых-бд" href="#%D1%80%D0%B0%D1%81%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B9,-%D0%B8%D1%85-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%B5%D0%B9-%D0%B8-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA-%D0%B2%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D1%85-%D0%B1%D0%B4"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D1%80%D0%B0%D1%81%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B9,-%D0%B8%D1%85-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%B5%D0%B9-%D0%B8-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA-%D0%B2%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D1%85-%D0%B1%D0%B4 </a></ins></h1><ins> </ins><p><ins><img src="files/main-section.png" alt="main-section"></ins></p> <h1><del>Рассмотрение абстракций и их взаимодействия в библиотеках встраиваемых БД.<a id="рассмотрение-абстракций-и-их-взаимодействия-в-библиотеках-встраиваемых-бд."></a></del></h1><del> Прежде всего стоит пояснить, что означает встраиваемая БД и чем они вызывают интерес к рассмотрению, чтобы найти для
этого время.
Встраимаевые БД - предоставляющие интерфейс стандартных операций с данными CRUD и поиска по ним, работающие напрямую с файлом на диске, которые встраиваются в процесс выполнения программы, а не выносятся в отдельный.
</del> <p>Часто возникает желание иметь простейшую архитектуру сервиса или программы, в которой будут отсутствовать избыточные компоненты и межсетевое взаимодействие. Это ощутимо сокращает силы и время на </p><ul><li> <ins>их реализацию, поддержку и погружение. Чтобы придерживаться такого подхода нужно уметь подбирать </ins><ins><strong>подходящие технологии и библиотеки</strong>.</ins><p><ins>Подбор может быть достаточно прямолинейным - формирование списка подходящих решений по их применяемой области, но, очевидно, что такой список окажется слишком большим и перенасыщенным. Сегодня век информации и потому её объём вокруг нас огромен, который человек физически не способен усвоить даже за всю жизнь, да-да представь себе. Осознание этой проблемы объема естесвенным образом приводит к формированию интеллектуального подхода - применения ряда <strong>аналитических практик</strong>, приводящих к сокращению кол-ва информации, способной быть усвоенной человеком в сроки, соответствующие решаемой задачи, и сохранению уровня её качества, релевантности. Т.е. подход, сокращающий список подходящих решений без погружения в исходной код до приемлимого и, в конечном итоге, одного.</ins></p><ins> </ins><p><ins>В данной статье применяется ряд таких практик, на примере подбора библиотек встраиваемых БД. Как таковая решаемая задача отсутствует, потому необходимости придти к выбору одной из них нету.</ins></p><ins> </ins><h2><ins>Цели <a id="цели" href="#%D1%86%D0%B5%D0%BB%D0%B8"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D1%86%D0%B5%D0%BB%D0%B8 </a></ins></h2><ins> </ins><li><ins>Сформировать список библиотек встраиваемых БД к рассмотрению.</ins></li><ins> </ins><li><ins>Сформировать список аналитических практик.</ins></li><ins> Определить</ins> <del>реализацию и поддержку.
При реализации эксперементальных программ удобно иметь файл с подходящей структурой данных, полученных из опыта.
Ряд БД базируется на различных алгоритмах.</del><p><del>Так же надо подчеркнуть, что рассматриваются именно структуры и взаимосвязи, без различных замеров производительности. Интерес именно в</del></p><del> </del><h2><del>Ручная допроверка<a id="ручная-допроверка"></a></del></h2><del> </del><p><del>Используя различные ресурсы(платные и бесплатные) добавить информации о библиотеках(интроспекция кода), напр. график динамики внесения изменений(комитов).</del></p><del> </del><h2><del>Цели.<a id="цели."></a></del></h2><del> </del><p><del><strong>Основной идеей таки является выработака практики общего осмотра устройства, структуры библиотек на примере встраиваемых БД на основе sqlite.</strong></del></p><del> </del><p><del>Процесс пути к пониманию заявленной темы рассмотрения не должен быть сложным,</del></p><del> </del><li><del>Сформировать список рассматриваемых БД.</del></li><del> Рассмотреть вспомогательные</del>  инструменты по анализу исходного кода <ins>библиотек, лежащих в основе практик.</ins><li><ins>Применить каждую практику отдельно по каждой БД из списка, описав полученные результаты.</ins></li><ins> </ins><h2><ins>Список БД <a id="список-бд" href="#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B1%D0%B4"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B1%D0%B4 </a></ins></h2> <del>библиотек.</del><li><del>Построить диаграммы абстракций.</del></li><del> </del><li><del>Описать преимущества и недостатки по каждой БД.</del></li><del> Список БД для рассмотрения.</del> </li> </ul> <p>В список можно внести огромное кол-во разных вариаций <ins>библиотек, как упоминалось ранее, но мы сократим</ins> <del>бибиотек: на разных языках, устаревших, в нереализованном состоянии и т.д. Но нужно ограничиться, чтобы сузить</del> его до таковых, которые <del>принесут полезную информацию и</del> могут быть использованы на практике в <ins>будущем(тут конечно каждый сам для себя должен представить, что именно может быть ему полезным, на чем он специализируется или к чему хотел бы приблизиться в своей деятельности).</ins> <del>будущем. А помочь в этом вопросе может личный опыт, знание предметных областей, в которых был он получен, свои идеи, к которым могут быть приложены полученные зания, и, конечно же, интуиция.</del> </p> <p>Помимо прочего, библиотеки должны быть написаны на чистом питоне для чтения исходного кода и <ins>технической</ins> <del>техничской</del> возможности анализа вспомогательными инструментами. Основной источник для поиска - <strong>Github</strong> <ins>.</ins><p><ins>Возьмем за кол-во три библиотеки, как минимально показательное, учитывая, что полученной информации по ним будет в конечном итоге много.</ins></p><ins> </ins><ul><li><ins><a href="https://tinydb.readthedocs.io/en/latest/"><span class="iconify" data-icon="bx:bx-link-external"></span> tinydb Link: https://tinydb.readthedocs.io/en/latest/ </a></ins></li><ins> </ins><li><ins><a href="https://github.com/RaRe-Technologies/sqlitedict"><span class="iconify" data-icon="bx:bx-link-external"></span> sqlitedict Link: https://github.com/RaRe-Technologies/sqlitedict </a></ins></li><ins> </ins><li><ins><a href="https://docs.peewee-orm.com/en/latest/peewee/playhouse.html#kv"><span class="iconify" data-icon="bx:bx-link-external"></span> peewee-kv Link: https://docs.peewee-orm.com/en/latest/peewee/playhouse.html#kv </a></ins></li><ins> </ins></ul><ins> </ins><h2><ins>Список практик <a id="список-практик" href="#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA </a></ins></h2><ins> </ins><p><ins>Приведем их список, применяемых для получения информации по каждой из библиотек, дающей как бы взгляд сверху на абстрактную сложность их внутреннего устройства без погружения в исходный код.</ins></p><ins> </ins><p><ins>Перечисление практик идет в порядке от общего к частному, т.е. самая первая описывает общую картину с наименьшим кол-вом деталей и степенью погружения, при этом больше всех затрагивает высокоуровневые абстракции, на которых библиотеки базируются:</ins></p><ins> </ins><ul><li><ins>Построение графа зависимостей модулей.</ins></li><ins> </ins><li><ins>Построение диаграммы  классов.</ins></li><ins> </ins><li><ins>Построение графа вызовов базового </ins><ins><strong>исполняемого сценария</strong>. Эта практика наиболее близка к реальной эксплуатации библиотеки, т.к. содержит ряд её вызовов, без которых выполнямая повседневно реальная работа бессмыслена:
</ins><ul><li><ins>Создание БД.</ins></li><ins> </ins><li><ins>Запись данных.</ins></li><ins> </ins><li><ins>Обновление данных.</ins></li><ins> </ins><li><ins>Получение, поиск данных.</ins></li><ins> </ins><li><ins>Удаление записи.</ins></li><ins> </ins></ul><ins> </ins></li><ins> </ins><li><ins>Построение графика цикломатической сложности.</ins></li><ins> </ins><li><ins>Построение графика halstead-измерений и суммарных характеристик. Суммарные характеристики - взятые из предыдущих практик в дополнение к halstead-измерениям.</ins></li><ins> </ins></ul><ins> </ins><h2><ins>Вспомогательные инструменты <a id="вспомогательные-инструменты" href="#%D0%B2%D1%81%D0%BF%D0%BE%D0%BC%D0%BE%D0%B3%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D0%B2%D1%81%D0%BF%D0%BE%D0%BC%D0%BE%D0%B3%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B </a></ins></h2><ins> </ins><p><ins>Перечислим инструменты с кратким описанием по каждому, чтобы в дальнейшем было понятно, для чего мы их используем и что от них ожидается.</ins></p><ins> </ins><p><ins>Ресурс, содержащий поддерживаемый <a href="https://github.com/analysis-tools-dev/static-analysis#python"><span class="iconify" data-icon="bx:bx-link-external"></span> список инструментов Link: https://github.com/analysis-tools-dev/static-analysis#python </a> по всевозможному анализу кода.</ins></p><ins> </ins><h3><ins>Pyreverse <a id="pyreverse" href="#pyreverse"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #pyreverse </a></ins></h3><ins> </ins><p><ins><a href="https://www.logilab.org/blogentry/6883"><span class="iconify" data-icon="bx:bx-link-external"></span> https://www.logilab.org/blogentry/6883 Link: https://www.logilab.org/blogentry/6883 </a></ins></p> </p> <ul><li><del>4https://dataset.readthedocs.io/en/latest/</del></li><del> </del><li><del>https://tinydb.readthedocs.io/en/latest/</del></li><del> </del><li><del>https://github.com/RaRe-Technologies/sqlitedict</del></li><del> </del><li><del>http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#kv</del></li><del> </del><li><del>http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#dataset</del></li><del> </del><li><del>https://lmdb.readthedocs.io/en/release/</del></li><del> </del><li><del>https://github.com/wbolster/plyvel</del></li><del> </del><li><del>https://github.com/twmht/python-rocksdb <em>based on LevelDB</em></del></li><del> </del><li><del>gdbm</del></li><del> </del><li><del>upscaledb</del></li><del> </del><li><del>http://traildb.io/docs/tutorial/</del></li><del> </del></ul><del> </del><h2><del>Вспомогательные инструменты.<a id="вспомогательные-инструменты."></a></del></h2><del> </del><p><del>Хорошо было бы опереться на результаты работы инструментов по анализу исходного кода, чтобы иметь больше информации для расширения общего взгляда на вещи и работы с предположениями.</del></p><del> </del><p><del>Полученная вспомогательная информация, впрочем, может быть и бесполезной, что выяснится уже при их практическом примененнии.</del></p><del> </del><h3><del>Pyreverse.<a id="pyreverse."></a></del></h3><del> </del><p><del>https://www.logilab.org/blogentry/6883
https://pylint.org/</del></p> <blockquote><p>Pyreverse analyses Python code and extracts UML class diagrams and package depenndencies.</p> </blockquote> <p> <ins>Утилита является частью пакета <a href="https://pylint.org"><span class="iconify" data-icon="bx:bx-link-external"></span> pylint Link: https://pylint.org </a>.</ins> Как видно из цитаты, </p><p> <ins>автоматически строит диаграммы классов. Эти диаграммы дадут нам  видение абстракций, которые содержит БД, и их взаимосвязей. При этом утилита позволяет указывать уровень глубины сканирования исходного кода.</ins><h3><ins>Pydeps <a id="pydeps" href="#pydeps"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #pydeps </a></ins></h3><ins> </ins><p><ins><a href="https://github.com/thebjorn/pydeps"><span class="iconify" data-icon="bx:bx-link-external"></span> https://github.com/thebjorn/pydeps Link: https://github.com/thebjorn/pydeps </a>.</ins></p><ins> </ins><p><ins>Утилита построения графа зависимостей с генерацией на осное формата <code>.dot</code> программного пакета <a href="http://www.graphviz.org/about/"><span class="iconify" data-icon="bx:bx-link-external"></span> Graphviz Link: http://www.graphviz.org/about/ </a>. Изображение графа генерируется разными цветами, логика в этом присутствует, но для нас она значения не имеет, поэтому не стоит обращать на это внимание.</ins></p><ins> </ins><h3><ins>Gprof2dot <a id="gprof2dot" href="#gprof2dot"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #gprof2dot </a></ins></h3><ins> </ins><p><ins><a href="https://github.com/jrfonseca/gprof2dot"><span class="iconify" data-icon="bx:bx-link-external"></span> https://github.com/jrfonseca/gprof2dot Link: https://github.com/jrfonseca/gprof2dot </a></ins></p><ins> Утилита строит</ins> <del>помогает автоматически построить диаграммы классов и импортируемых зависимостей.</del><h3><del>Pycallgraph.<a id="pycallgraph."></a></del></h3><del> </del><p><del>https://pycallgraph.readthedocs.io/en/master/</del></p><del> Понятная альтернатива </del><del><a href="#pyreverse">pyreverse Link: #pyreverse </a>. Строит</del> </p> граф вызовов указанного исполняемого сценария, поэтому необходимо в нем иметь <ins>вызовы оптимального кол-ва </ins><ins><strong>базовых абстракций</strong> библиотеки. Строится из файла формата </ins><ins><code>.pstats</code> стандартной библиотеки </ins><ins><a href="https://docs.python.org/3/library/profile.html#the-stats-class"><span class="iconify" data-icon="bx:bx-link-external"></span> Stats Link: https://docs.python.org/3/library/profile.html#the-stats-class </a>. В дополнение к ней нужно иметь предустановленный программный пакет </ins><ins><a href="https://graphviz.org/download/#linux"><span class="iconify" data-icon="bx:bx-link-external"></span> GraphViz Link: https://graphviz.org/download/#linux </a> и в частности утилиту </ins><ins><code>dot</code>.</ins><h3><ins>Radon <a id="radon" href="#radon"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #radon </a></ins></h3><ins> </ins><p><ins><a href="https://radon.readthedocs.io/en/latest/"><span class="iconify" data-icon="bx:bx-link-external"></span> https://radon.readthedocs.io/en/latest/ Link: https://radon.readthedocs.io/en/latest/ </a></ins></p><ins> </ins><p><ins>Утилита сканирует исходный код и выводит показатели следующих измерений:</ins></p><ins> </ins><ul><li><ins>Cyclomatic Complexity (i.e. McCabe’s Complexity)</ins></li><ins> </ins><li><ins>Halstead metrics</ins></li><ins> </ins></ul><ins> </ins><h3><ins>McCabe <a id="mccabe" href="#mccabe"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #mccabe </a></ins></h3><ins> </ins><p><ins><a href="https://github.com/pycqa/mccabe"><span class="iconify" data-icon="bx:bx-link-external"></span> https://github.com/pycqa/mccabe Link: https://github.com/pycqa/mccabe </a></ins></p><ins> </ins><p><ins>Утилита в дополнение к <strong>radon</strong> генерирует граф в текстовом формате <code>dot</code> по которому можно сгенерировать отображение его прохождения потоком управления.</ins></p><ins> </ins><h2><ins>Рассмотрение <a id="рассмотрение" href="#%D1%80%D0%B0%D1%81%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D0%BD%D0%B8%D0%B5"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D1%80%D0%B0%D1%81%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D0%BD%D0%B8%D0%B5 </a></ins></h2><ins> </ins><h3><ins>Построение графа зависимостей <a id="построение-графа-зависимостей" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B0-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B0-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9 </a></ins></h3><ins> </ins><p><ins>На графах не отображаются модули стандартной библиотеки, а только лишь внешние зависимости. Сам сканируемый пакет отображается в именованных прямоугольных рамках, очерчивающих его модули, отображаемые окружностями. Внешние зависимости отображаются в виде изображений папок с их именами.</ins></p><ins> </ins><p><ins>Такой граф дает визуальное представление полной картины того, как исходный код структурирован, какие верхнеуровневые компоненты содержит и как они взаимосвязаны.</ins></p><ins> </ins><h4><ins>TinyDB <a id="tinydb" href="#tinydb"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #tinydb </a></ins></h4><ins> </ins><pre><ins><code>pydeps --noshow --cluster --keep-target-cluster --rmprefix tinydb. -T png -o deps.png venv/lib/python3.8/site-packages/tinydb
</code></ins></pre><ins> </ins><p><ins><img src="files/tinydb/deps.png" alt=""></ins></p><ins> </ins><p><ins>Вот первое отображение структуры компонентов из которых собрана библиотека. Слева основной импортируемый модуль, который вбирает функционал остальных, что видно по направленным стрелкам-связям.</ins></p><ins> </ins><h4><ins>Sqlitedict <a id="sqlitedict" href="#sqlitedict"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #sqlitedict </a></ins></h4><ins> </ins><p><ins><img src="files/sqlitedict/deps.png" alt=""></ins></p><ins> </ins><p><ins>Библиотека не имеет никаких зависимостей и даже не скомпанована как пакет, все абстракции содержатся в одном модуле в 550 строк кода и их всего 2, одна из которых основная, верхнеуровневая. Это сразу знак того, что порог входа по изучению нулевой.</ins></p><ins> </ins><p><ins>Казалось бы сказать тут нечего, но это косвенно и обозначает преимущество.</ins></p><ins> </ins><h4><ins>Peewee-kv <a id="peewee-kv" href="#peewee-kv"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #peewee-kv </a></ins></h4><ins> </ins><p><ins>Фактически это модуль пакета <code>playhouse</code> который расширением функционала реализованного в библиотеке <strong>peewee</strong>.</ins></p><ins> </ins><pre><ins><code>pydeps --include-missing --max-bacon=1 --noshow --cluster --keep-target-cluster --rmprefix playhouse. -T png -o source-deps.png venv/lib/python3.8/site-packages/playhouse
</code></ins></pre><ins> </ins><p><ins>Команда генерирует взаимосвязи модулей из сканируемого пакета которые нас не интересуют. поэтому следующее изображение отредактировано вручную, а вот ссылка на исходное <a href="files/peewee-kv/source-deps.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> source-deps.png Link: files/peewee-kv/source-deps.png </a> для сравнения.</ins></p><ins> </ins><p><ins><img src="files/peewee-kv/edited-deps.png" alt=""></ins></p><ins> </ins><p><ins>Наш лидер по сложности из 3х, что впринципе и так понятно, зная о том, что это расширение. Тут мы это просто видим, не погружаясь в код.</ins></p><ins> </ins><h3><ins>Построение диаграммы классов <a id="построение-диаграммы-классов" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2 </a></ins></h3><ins> </ins><p><ins>В паре секции присутствует ссылка на исходную диаграмму - большое по размеру изображение, включающее все что нужно и нет, и отредактированное изображение базовых абстракций библиотеки, отображающее интересующую нас суть.</ins></p><ins> </ins><h4><ins>TinyDB <a id="tinydb" href="#tinydb"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #tinydb </a></ins></h4><ins> </ins><pre><ins><code>pyreverse -o png venv/lib/python3.8/site-packages/tinydb
</code></ins></pre><ins> </ins><p><ins><img src="files/tinydb/classes.png" alt=""></ins></p><ins> </ins><p><ins>Достаточно много классов, потому можно предположить, что библиотека предоставляет возможности расширения своими кастомными классами, собственно на это указывают <strong>generalization</strong> связи, например <code>Storage &lt;- MemoryStorage</code>.</ins></p><ins> </ins><p><ins>Семантичные имена, такие как <code>Middleware, Query, JsonStorage</code>, дают понимание о том что есть некий общий слой обработки, какой-то язык запросов, ну и хранение в конкретном формате <code>json</code>.</ins></p><ins> </ins><p><ins>Связи у классов <code>Middleware, Query</code> с иными в диаграмме полностью отсутствуют, а значит для их фактического установления необходимо погружаться в код, либо документацию, что уже требует небольших дополнительных усилий, но небольших, потому что библиотека самодостаточно и все содержит в себе.</ins></p><ins> </ins><h4><ins>Sqlitedict <a id="sqlitedict" href="#sqlitedict"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #sqlitedict </a></ins></h4><ins> </ins><pre><ins><code>pyreverse -o png venv/lib/python3.8/site-packages/sqlitedict.py
</code></ins></pre><ins> </ins><p><ins>Полное отображение <a href="files/sqlitedict/source-classes.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> source-classes.png Link: files/sqlitedict/source-classes.png </a>.</ins></p><ins> </ins><p><ins><img src="files/sqlitedict/classes.png" alt=""></ins></p><ins> </ins><p><ins>Выглядит минималистично, прямо сейчас открывай код и читай, нет нужды в чтении документации. Напрямую работа с БД происходит только лишь через <code>SqliteDict</code>, вторая добавляет способность многопоточности и не подразумевает прямых обращений к ней из исполняемого сценария.</ins></p><ins> </ins><p><ins>Семантика имени <code>SqliteMultithread</code> говорит о способности работы с потоками. Не читая документации мы сразу получили такую информацию о часто интересующем нас вопросе, которую мы не имеем в двух других диаграммах.</ins></p><ins> </ins><h4><ins>Peewee-kv <a id="peewee-kv" href="#peewee-kv"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #peewee-kv </a></ins></h4><ins> </ins><pre><ins><code>pyreverse -o png venv/lib/python3.8/site-packages/playhouse/kv.py
</code></ins></pre><ins> </ins><p><ins>Полное отображение <a href="files/peewee-kv/source-classes.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> source-classes.png Link: files/peewee-kv/source-classes.png </a>.</ins></p><ins> </ins><p><ins><img src="files/peewee-kv/classes.png" alt=""></ins></p><ins> </ins><p><ins>Как и <strong>sqlitedict</strong> имеет минимум абстракций, передающих семантику именами классов и их атрибутов. Не забываем, что изобилие классов исходного кода базовой библиотеки не строилось.</ins></p> <del>вызовы, покрывающие по нисходящей(от высокоуровневых выовов к низкоуровневым) наибольшую часть абстракций библиотеки.</del><h3><del>Sourcegraph.<a id="sourcegraph."></a></del></h3><del> </del><p><del>https://about.sourcegraph.com/</del></p><del> </del><p><del>Не нашел наглядных примеров для понимания, что этот сервис может предоставить.</del></p><del> </del><h3><del>Prospector.<a id="prospector."></a></del></h3><del> </del><p><del>https://github.com/PyCQA/prospector</del></p><del> </del><p><del>Некий аггрегатор анализирующих инструментов. Может дать информацию сразу по многим аспектом. Теоретически выявляет места, на которые сразу стоит обратить внимание.</del></p><del> </del><p><del>Полезно использовать при сравнении полученной информации по множеству библиотек в случае подбора более подходящей под решение.</del></p><del> </del><h3><del>Pylama.<a id="pylama."></a></del></h3><del> </del><p><del>https://github.com/klen/pylama</del></p><del> </del><p><del>Альтернатива <a href="#prospector">prospector Link: #prospector </a> менее популярная , судя по показателям в Гитхабе.</del></p><del> </del><h3><del>Vulture.<a id="vulture."></a></del></h3><del> </del><p><del>https://github.com/jendrikseipp/vulture</del></p><del> </del><p><del>Динамический поисковик неиспользуемого кода. Полезно для видения, насколько исходный код бибилиотеки находится в актуальном состоянии, в каких углах запылилась.</del></p><del> </del><h3><del>Поддерживаемый список библиотек по анализу кода.<a id="поддерживаемый-список-библиотек-по-анализу-кода."></a></del></h3><del> </del><p><del>https://github.com/analysis-tools-dev/static-analysis#python</del></p><del> </del><p><del>Может осветить еще потенциальнополезные утилиты или нет. Надо выделить на это отдельное время.</del></p><del> </del><h3><del>Pydeps<a id="pydeps"></a></del></h3><del> </del><p><del>Альтернатива использования  <strong>pyreverse</strong></del></p><del> </del><p><del>https://github.com/thebjorn/pydeps</del></p><del> </del><h3><del>Radon<a id="radon"></a></del></h3><del> </del><p><del>https://radon.readthedocs.io/en/latest/</del></p><del> </del><h2><del>Общая практика рассмотрения.<a id="общая-практика-рассмотрения."></a></del></h2><del> </del><p><del>Список единых операций, выполняемых для получения информации о каждой из библиотек, дающей как бы взгляд со стороны на сложность их внутреннего устройства без погружения в исходный код. Полученные результаты вынесены в отдельную секцию.</del></p><del> </del><li><del>Построение диаграмм взаимосвязей модулей и абстракций.</del></li>  <h3>Построение графа вызовов <ins><a id="построение-графа-вызовов" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B0-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B0-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2 </a></ins><p><ins>Граф базового исполняемого сценария, описанного ранее, будет строиться следующими командами исполненными последовательно для каждого отдельно.</ins></p><ins> </ins><pre><ins><code>$ python -m cProfile -s nfl -o basic-scenario.pstats basic-scenario.py
$ gprof2dot -f pstats basic-scenario.pstats -o basic-scenario.dot
$ dot -Tpng basic-scenario.dot -o basic-scenario.png
</code></ins></pre><ins> </ins><p><ins>Код приведенный в каждой секции ниже содержится в <code>basic-scenario.py</code>, который сканируется командами выше. Все вызовы из него должны интуитивно читаться на изображении без каких-либо усилий.</ins></p><ins> </ins><p><ins>Как и в части диаграмм классов присутствует полное и отредактированное изображения графов.</ins></p><ins> </ins><h4><ins>TinyDB <a id="tinydb" href="#tinydb"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #tinydb </a></ins></h4> </h3> <pre><code> <del>базового сценария и упрощенной диаграммы их последовательности:
</del><ul><li><del>Создание БД.</del></li><del> </del><li><del>Запись данных.</del></li><del> </del><li><del>Обновление данных.</del></li><del> </del><li><del>Получение, поиск данных.</del></li><del> </del></ul><del> </del><h2><del>Рассмотрение.<a id="рассмотрение."></a></del></h2><del> </del><p><del>В общем, приминимо к каждой библиотеке будут выполнены идентичиные шаги анализа, а вот сопровождающее описание будет частным и самым ценным в проделанной работе.</del></p><del> </del><p><del>Шаги:</del></p><del> </del><ul><li><del>prospector</del></li><del> </del><li><del>Граф вызовов pycallgraph к минимальному использованию БД, семантически-общий сниппет кода.</del></li><del> </del><li><del></del></li></ul><del> </del><h3><del>Dataset 1.4.1<a id="dataset-1.4.1"></a></del></h3><del> </del><p><del>Надстройка SQLAlchemy, что сразу говорит о многообразии абстракций, состоящих из двух слоёв: <strong>SQLAlchemy ORM, SQLAlchemy Core</strong>.</del></p><del> </del><p><del>Сама надстройка объявляет 2 основные абстракции: <strong>Database, Table</strong> описанных в 2х модулях суммарно на 1025 строк
кода, имея, тем самым, низкий порог входа понимания их диаграммы взаимодействия.</del></p><del> </del><pre><del><code>prospector --with-tool vulture
</code></del></pre><del> </del><blockquote><p><del><a href="files/dataset/prospector.txt">Анализ Link: files/dataset/prospector.txt </a> кода.</del></p><del> </del></blockquote><del> </del><pre><del><code>from pycallgraph import PyCallGraph
from pycallgraph.output import GraphvizOutput

import dataset


with PyCallGraph(output=GraphvizOutput()):
    db = dataset.connect('sqlite:///:memory:')
    table = db['sometable']
    table.insert(dict(name='John Doe', age=37))
    table.insert(dict(name='Jane Doe', age=34, gender='female'))
    john = table.find_one(name='John Doe')
</code></del></pre><del> </del><blockquote><p><del><a href="files/dataset/pycallgraph.png">Граф Link: files/dataset/pycallgraph.png </a> вызовов. Содержит очень большой набор вызовов и множества модулей.</del></p><del> </del></blockquote><del> </del><pre><del><code>pyreverse  -AS -f ALL -o png  venv/lib/python3.7/site-packages/dataset
</code></del></pre><del> </del><blockquote><p><del>Полученная <a href="files/dataset/classes.png">диаграмма классов Link: files/dataset/classes.png </a>. Очень громоздкая диаграмма с большим кол-вом классов и взаимосвязей. Сказывается базирование на sqlalchemy.</del></p><del> </del><p><del><a href="files/dataset/packages.png">Диаграмма связей модулей Link: files/dataset/packages.png </a>.</del></p><del> </del></blockquote><del> </del><h3><del>TinyDB 4.3.0<a id="tinydb-4.3.0"></a></del></h3><del> </del><pre><del><code>prospector --with-tool vulture
</code></del></pre><del> </del><blockquote><p><del><a href="files/tinydb/prospector.txt">Анализ Link: files/tinydb/prospector.txt </a> кода.</del></p><del> </del></blockquote><del> from pycallgraph import PyCallGraph
from pycallgraph.output import GraphvizOutput

</del> from tinydb import TinyDB, Query

 <ins>def main():
    db = TinyDB('test.tinydb')
    table = db.table(TinyDB.default_table_name)
    r1 = table.insert({'name': 'John', 'age': 22})
    r2 = table.insert({'name': 'Van', 'car': 'volvo'})
   </ins> <del>from tinydb.storages import MemoryStorage


with PyCallGraph(output=GraphvizOutput()):
    db = TinyDB(storage=MemoryStorage)
   </del> User = Query()
    <ins>upd = table.update({'car': 'bmw'}, User.age == 22)
    records = table.search(User.name == 'John')
    table.remove(User.name == 'Van')

if __name__ == '__main__':
    main()
</ins><p><ins>Полный граф <a href="files/tinydb/basic-scenario.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> basic-scenario.png Link: files/tinydb/basic-scenario.png </a></ins></p><ins> </ins><p><ins><img src="files/tinydb/basic-scenario-edited.png" alt=""></ins></p><ins> </ins><p><ins>Видно как операции объекта <code>table</code> обращаются к объекту <code>storage</code> и обращение к нему в свою очередь объекта <code>database</code>. Сценарий очень хорошо читается на самом изображении, вплоть до сброса данных на диск, но сопоставив его с изображением диаграммы классов появляется неясность из-за отсутствия абстракций <code>Middleware, Document, Query</code>. Понятно, что они где-то неявно учавствует(как минимум <code>Document, Query</code>) и логически можно установить это место, но хотелось бы это просто видеть.</ins></p><ins> </ins><h4><ins>Sqlitedict <a id="sqlitedict" href="#sqlitedict"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #sqlitedict </a></ins></h4><ins> </ins><pre><ins><code>from sqlitedict import SqliteDict

def main():
    db = SqliteDict('test.sqlite', autocommit=True)
    db['user1'] = {'name': 'John', 'age': 22}
    db['user2'] = {'name': 'Van', 'car': 'volvo'}
    db['user1']['car'] = 'bmw'
    u = db['user1']
    del db['user2']

if __name__ == '__main__':
    main()
</code></ins></pre><ins> </ins><p><ins>Полный граф <a href="files/sqlitedict/basic-scenario.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> basic-scenario.png Link: files/sqlitedict/basic-scenario.png </a></ins></p><ins> </ins><p><ins><img src="files/sqlitedict/basic-scenario-edited.png" alt=""></ins></p><ins> </ins><p><ins>Явным концептуальным отличием(логика помимо CRUD операций, создания БД) от предшественника является наличие объекта синхронизации потоков <code>queue</code>, т.к. вообще все вызовы <code>execute</code> производятся классом <code>SqliteMultithread</code>. Это мы знаем из соответстующей диаграммы классов, а благодаря графу еще и видим, где это происходит.</ins></p><ins> </ins><h4><ins>Peewee-kv <a id="peewee-kv" href="#peewee-kv"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #peewee-kv </a></ins></h4><ins> </ins><pre><ins><code>from playhouse.kv import KeyValue

def main():
    db = KeyValue()
    db['user1'] = {'name': 'John', 'age': 22}
    db['user2'] = {'name': 'Van', 'car': 'volvo'}
    db['user1']['car'] = 'bmw'
    records = db[db.key == 'user1']
    del db['user2']
    
if __name__ == '__main__':
    main()
</code></ins></pre><ins> </ins><p><ins>Полный граф <a href="files/peewee-kv/basic-scenario.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> basic-scenario.png Link: files/peewee-kv/basic-scenario.png </a></ins></p><ins> </ins><p><ins><img src="files/peewee-kv/basic-scenario-edited.png" alt=""></ins></p><ins> </ins><p><ins>Изображение сразу же демонстрирует большую глубину графа вызовов по сравнению с <strong>tinydb, sqlitedict</strong> и малую степень участия в нем верхнеуровневой абстракции <code>kv</code>, т.е. визуально проявляется степень(она же глубина) участия базовой зависимости - <strong>peewee</strong>.</ins></p><ins> </ins><p><ins>Отличное раскрывающее дополнение к соответствующим графу зависимостей и диаграмме классов.</ins></p><ins> </ins><h3><ins>Построение графика цикломатической сложности <a id="построение-графика-цикломатической-сложности" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8 </a></ins></h3><ins> </ins><p><ins>Для нахождения <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity"><span class="iconify" data-icon="bx:bx-link-external"></span> цикломатической сложности Link: https://en.wikipedia.org/wiki/Cyclomatic_complexity </a> воспользуемся утилитой <strong>radon</strong> и произведем нижеследующий вызов для каждой библиотеки отдельно.</ins></p><ins> </ins><pre><ins><code>radon cc -s --md venv/lib/python3.8/site-packages/tinydb
</code></ins></pre><ins> </ins><p><ins>Формат <code>md</code> взят для прощей читаемости и дальнейшей обработки полученных данных. Полученные данные <a href="files/tinydb/cc.md"><span class="iconify" data-icon="bi:markdown"></span> tiny.md Link: files/tinydb/cc.md </a>, <a href="files/sqlitedict/cc.md"><span class="iconify" data-icon="bi:markdown"></span> sqlitedict.md Link: files/sqlitedict/cc.md </a>, <a href="files/peewee-kv/cc.md"><span class="iconify" data-icon="bi:markdown"></span> kv.md Link: files/peewee-kv/cc.md </a>.</ins></p><ins> </ins><p><ins>Впринципе, данные таблицы уже показывают нам какая библиотека состоит из большего кол-ва сканируемых классов, методов, функций и число сложности у каждого из них. Этого достаточно, чтобы, опять же, не углубляясь в детали, получить информацию об отличии цикломатических сложностей. Но такое текстовое, табличное представление не настолько наглядно при чтении и сопоставлении одновременно трех таких. Для упрощения этого процесса можно конечно слить все таблицы в один файл и, прокручивая их, сравнивать числовые показатели, аналитически их сопоставляя(что и где больше, насколько хорошо или плохо ли это).</ins></p><ins> </ins><p><ins>Но для большего удобства восприятия полученных значений мы можем построить график с их цветовой передачей на основе имеющихся табличных файлов с помощью <strong>matplotlib, numpy</strong>. По задумке глубина цвета(темный тон) на графике сразу интуитивно выделит места, требующие внимания.</ins></p><ins> </ins><p><ins>Код построения графика <a href="files/cc_ranks.py"><span class="iconify" data-icon="teenyicons:python-outline"></span> cc_ranks.py Link: files/cc_ranks.py </a> и само изображение.</ins></p><ins> </ins><p><ins><img src="files/CC-chart.png" alt=""></ins></p><ins> </ins><p><ins>Как и было задумано, изображение демонстрирует такие показатели, как объем и глубина цвета и мы видим без аналитического сопоставления, что по объему(количество ячеек) доминирует <strong>tinydb</strong>, а по глубине цвета(наибольшее значение сложности) <strong>sqlitedict</strong>.</ins></p><ins> </ins><p><ins>Цветовая шкала справа имеет максимальное значение <code>20</code> как максимальную сложность лишь для адаптации к нашему конкретному случаю, в то время как согласно <a href="https://radon.readthedocs.io/en/latest/commandline.html#the-cc-command"><span class="iconify" data-icon="bx:bx-link-external"></span> заявленным категориям Link: https://radon.readthedocs.io/en/latest/commandline.html#the-cc-command </a> оно должно быть <code>41+</code>.</ins></p><ins> </ins><p><ins>В дополнение мы можем вывести самый сложный метод из <strong>sqlitedict</strong> и построить его граф потока управления следующими командами:</ins></p><ins> </ins><pre><ins><code>python -m mccabe -d venv/lib/python3.8/site-packages/sqlitedict.py &gt; mccabe.dot
dot -Tpng mccabe.dot -o mccabe.png
</code></ins></pre><ins> </ins><p><ins>Полученный граф <a href="files/sqlitedict/mccabe.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> mccabe.png Link: files/sqlitedict/mccabe.png </a>, в котором визуально заметен метод <code>SqliteMultithread.run</code> как самый глубокий.</ins></p><ins> </ins><h3><ins>Построение графика Halstead-измерений и суммарных характеристик <a id="построение-графика-halstead-измерений-и-суммарных-характеристик" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0-halstead-%D0%B8%D0%B7%D0%BC%D0%B5%D1%80%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B8-%D1%81%D1%83%D0%BC%D0%BC%D0%B0%D1%80%D0%BD%D1%8B%D1%85-%D1%85%D0%B0%D1%80%D0%B0%D0%BA%D1%82%D0%B5%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0-halstead-%D0%B8%D0%B7%D0%BC%D0%B5%D1%80%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B8-%D1%81%D1%83%D0%BC%D0%BC%D0%B0%D1%80%D0%BD%D1%8B%D1%85-%D1%85%D0%B0%D1%80%D0%B0%D0%BA%D1%82%D0%B5%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA </a></ins></h3><ins> </ins><p><ins>Для каждой библиотеки получим список <a href="https://en.wikipedia.org/wiki/Halstead_complexity_measures"><span class="iconify" data-icon="bx:bx-link-external"></span> halstead-измерений Link: https://en.wikipedia.org/wiki/Halstead_complexity_measures </a> следующей командой отдельно.</ins></p><ins> </ins><pre><ins><code>python -m radon hal venv/lib/python3.8/site-packages/sqlitedict.py
</code></ins></pre><ins> </ins><p><ins>Полученные данные <a href="files/sqlitedict/hal.txt"><span class="iconify" data-icon="bi:file-earmark-text"></span> sqlitedict.txt Link: files/sqlitedict/hal.txt </a>, <a href="files/peewee-kv/hal.txt"><span class="iconify" data-icon="bi:file-earmark-text"></span> kv.txt Link: files/peewee-kv/hal.txt </a>, <a href="files/tinydb/hal.txt"><span class="iconify" data-icon="bi:file-earmark-text"></span> tinydb.txt Link: files/tinydb/hal.txt </a> обработаем и возьмем из них только базовые <code>h1, h2, N1, N2</code> которые обозначают: <strong>количество различных операторов, количество различных операндов, количество всех операторов, количество всех операндов</strong> соответственно. Вычисляемые измерения брать не будем, они имеют сомнительный смысл, к тому же их значения достаточно велики, что искажает значимость базовых при их совместном отображении.</ins></p><ins> </ins><p><ins>Добавим суммарные характеристики <code>Dependencies, Classes count, Graph calls, CC targets count, CC max complexity</code> из ранее полученных результатов рассмотрения. Для этого их надо посчитать вручную.</ins></p><ins> </ins><p><ins>Пожалуй надо учесть особенность библиотеки <strong>peewee-kv</strong>, что она базируется но мощном ОРМ, и ввести только для неё дополнительный коэфициент, который равен его вероятной сложности, и умножить на него значения всех имеющихся измерений. Для полученных отмасштабированных данных добавим второй график, в котором данные по <strong>sqlitedict, tinydb</strong> будут идентичны первому, тем самым это приблизит наше видение к действительной сложности <strong>peewee-kv</strong>.</ins></p><ins> </ins><p><ins>Коэффициент вычислим упрощенным способом, вычислив его из суммарного количества строк исходного кода ОРМ и его расширения, допуская, что рост всех значений измерений пропорционален росту кол-ва строк кода. Итого <code>7747 / 173 = 44.78</code>, коэфициент получается слишком большой. Сократим число до одного порядка, т.к. точное значение знать ненужно, важен лишь факт, что оно значительно больше <code>1</code>, т.е. коэфициент равен числу <code>10</code>.</ins></p><ins> </ins><p><ins>Код преобразования полученных данных halstead-измерений и построения графика <a href="files/hal.py"><span class="iconify" data-icon="teenyicons:python-outline"></span> hal.py Link: files/hal.py </a>, <a href="files/radar.py"><span class="iconify" data-icon="teenyicons:python-outline"></span> radar.py Link: files/radar.py </a>.</ins></p><ins> </ins><p><ins><img src="files/summary-chart.png" alt=""></ins></p><ins> </ins><p><ins>Формы всех зон покрытия на верхнем графике имеют схожие очертания, иными словами аномальные отличия отсутствуют по каким-либо измерениям, что можно интерпретировать как относительно равную простоту библиотек <strong>sqlitedict, tinydb</strong>. Однако по двум значениям синяя зона наиболее отдалена от красной: <code>h1, CC targets count</code>.</ins></p><ins> </ins><p><ins>Для <strong>peewee-kv</strong> идея масштабирования доп. коэфициентом сразу отобразила, что в действительности библиотека является намного сложнее остальных, т.к. зона покрытия желтым цветом на нижнем графике резко расширилась по сравнению с первым и охватила остальные зоны, при этом она была наименьшая на верхнем.</ins></p><ins> </ins><h2><ins>Заключение <a id="заключение" href="#%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5"><span class="iconify" data-icon="majesticons:hashtag-line"></span> Link: #%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5 </a></ins></h2><ins> </ins><p><ins>Подведем итоги. Просмотрим быстрым взглядом <a href="#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA"><span class="iconify" data-icon="majesticons:hashtag-line"></span> по заявленному порядку Link: #%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA </a> все произведенные действия и их результаты. Как и подразумевалось, мы получили достаточно информации об устройстве рассматриваемых объектов для того, чтобы сделать о нем какие-либо выводы. Например, для меня диаграммы зависимостей и классов являются самыми показательными и, при необходимости брать наипростейший вариант, выбрал бы <strong>sqlitedict</strong>, а в случае необходимости кастомизации операций и хранения данных - <strong>peewee-kv</strong>, который оказался наисложнейшим из перечисленных при взятии во внимание его фундамента.</ins></p><ins> </ins><p><ins>Вообщем, мы не делаем тут выбор, к определенным требованиям свой подходящий кандидат.</ins></p> </code></pre> </div> <del>db.insert({'name': 'John', 'age': 22})
    db.insert({'name': 'Van', 'car': 'volvo'})
    db.search(User.name == 'Van')
</del><blockquote><p><del><a href="files/tinydb/pycallgraph.png">Граф Link: files/tinydb/pycallgraph.png </a> вызовов. Содержит крошечный набор вызовов.</del></p><del> </del></blockquote><del> </del><pre><del><code>pyreverse  -AS -f ALL -o png  venv/lib/python3.7/site-packages/tinydb
</code></del></pre><del> </del><blockquote><p><del>Полученная <a href="files/tinydb/classes.png">диаграмма классов Link: files/tinydb/classes.png </a>.</del></p><del> </del><p><del><a href="files/tinydb/packages.png">Диаграмма связей модулей Link: files/tinydb/packages.png </a>.</del></p><del> </del></blockquote><del> </del><h3><del>Sqlitedict 1.7.0<a id="sqlitedict-1.7.0"></a></del></h3><del> </del><ul><li><p><del>Минимализм, выраженный 1м модулем из 550 строк кода.</del></p><del> </del></li><del> </del><li><p><del>Всего <u>2 абстракции и 1 основная</u>, т.е. для взаимодействия с данными используется <strong>SqliteDict</strong>, предоставляющий  соответствующий интерфейс, который обращается к кастомному <strong>SqliteMultithread</strong>. Этот объект уже напрямую выполняет операции в БД.</del></p><del> </del><pre><del><code class="language-mermaid">sequenceDiagram
participant main
participant SD as calendar:SqliteDict
participant SMT as connection:SqliteMultithread
main-&gt;&gt;+SD: calendar["today"]
SD-&gt;&gt;+SMT: connection.execute(sql)
Note over SMT: select value from calendar where key=today
SMT--&gt;&gt;-SD: "day off"
SD--&gt;&gt;-main: "day off"
</code></del></pre><del> </del></li><del> </del><li><p><del>На уровне БД схема таблиц(они же словари) организована наипростейшим образом без возможности кастомизации. <strong>Ключ</strong> объявлен строковым, а <strong>значение</strong> бинарным типами. Таким образом на уровне питона <u>неполностью эмулируются возможности словаря</u>.</del></p><del> </del><pre><del><code>complex_discount = SqliteDict('db.sqlite')
complex_discount[('pencil', 'case', 'eraser')] = 15

sqlite3.InterfaceError: Error binding parameter 0 - probably unsupported type.
</code></del></pre><del> </del></li><del> </del><li><p><del>Автогенерируемый <strong>индекс</strong> по ключу.</del></p><del> </del></li><del> </del><li><p><del>Поддержка кастомной сериализации значений</del></p><del> </del><pre><del><code>rss = SqliteDict('db.sqlite', encode=xml_encode, decode=xml_decode)
</code></del></pre><del> </del></li><del> </del><li><p><del>Поддержка многопоточности.</del></p><del> </del><p><del>Следует отметить, что в данной реализации объект-словарь необходимо разделять между потоками.</del></p><del> </del><pre><del><code>def job(job_results):
	k, v = fetch()
	job_results[k] = v

job_results = SqliteDict('db.sqlite')

t1 = Thread(target=job, args=(job_results, ))
t2 = Thread(target=job, args=(job_results, ))
</code></del></pre><del> </del></li><del> </del><li><p><del>Зачем-то оставлен режим создания БД в памяти <code>:memory:</code>. Было бы логичным его убрать для позиционируемой персистентности  словаря.</del></p><del> </del></li><del> </del><li><p><del>Хороший кандидат для быстрого старта и фокусировки на логике работы с данными, но остается неясность в том, как будет вести себя объект-словарь при различных вариациях параметров <code>autocommit, journal_mode</code>.</del></p><del> </del></li><del> </del></ul><del> </del><h2><del>Результаты применения общей практики.<a id="результаты-применения-общей-практики."></a></del></h2><del> </del><h3><del>Dataset.<a id="dataset."></a></del></h3><del> </del><h4><del>Диаграммы.<a id="диаграммы."></a></del></h4><del> </del><p><del><img src="files/dataset/packages.png" alt="packages"></del></p><del> </del><p><del><img src="files/dataset/classes.png" alt="classes"></del></p><del> </del><h3><del>TinyDB.<a id="tinydb."></a></del></h3><del> </del><p><del><img src="files/tinydb/packages.png" alt="packages"></del></p><del> </del><p><del><img src="files/tinydb/classes.png" alt="classes"></del></p><del> </del><h3><del>Sqlitedict<a id="sqlitedict"></a></del></h3><del> </del><p><del><img src="files/sqlitedict/classes.png" alt="classes"></del></p> 
        </div>
        <div id="toc" class="col-lg-3 order-1 order-lg-2">
            <ul><li><a href="#цели">Цели</a></li><li><a href="#список-бд">Список БД</a></li><li><a href="#список-практик">Список практик</a></li><li><a href="#вспомогательные-инструменты">Вспомогательные инструменты</a><ul><li><a href="#pyreverse">Pyreverse</a></li><li><a href="#pydeps">Pydeps</a></li><li><a href="#gprof2dot">Gprof2dot</a></li><li><a href="#radon">Radon</a></li><li><a href="#mccabe">McCabe</a></li></ul></li><li><a href="#рассмотрение">Рассмотрение</a><ul><li><a href="#построение-графа-зависимостей">Построение графа зависимостей</a></li><li><a href="#построение-диаграммы-классов">Построение диаграммы классов</a></li><li><a href="#построение-графа-вызовов">Построение графа вызовов</a></li><li><a href="#построение-графика-цикломатической-сложности">Построение графика цикломатической сложности</a></li><li><a href="#построение-графика-halstead-измерений-и-суммарных-характеристик">Построение графика Halstead-измерений и суммарных характеристик</a></li></ul></li><li><a href="#заключение">Заключение</a></li></ul>
        </div>
    </div>
    </div>

<script src="https://buttons.github.io/buttons.js"></script>
</body>
</html>