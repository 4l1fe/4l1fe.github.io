<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="/files/favicon.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css"
          rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl"
          crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="/files/css/style.css">
    <title>ТехнологоблогЪ</title>
</head>
<body>
<nav class="navbar navbar-light bg-white border-bottom border-secondary sticky-top mb-1">
    <div class="container-fluid d-flex justify-content-center ">
            <a class="navbar-brand fs-3" href="/">Технологоблог<b>Ъ</b></a>
            <span class="mx-2"><a class="github-button mx-2" href="https://github.com/4l1fe/4l1fe.github.io/subscription" data-icon="octicon-eye" data-size="large" aria-label="Watch 4l1fe/4l1fe.github.io on GitHub">Watch</a></span>
            <span class="mx-2"><a class="github-button mx-2" href="https://github.com/4l1fe/4l1fe.github.io" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star 4l1fe/4l1fe.github.io on GitHub">Star</a></span>
    </div>
</nav>
<div class="container">
        <div class="row">
        <div id="content" class="col-lg-9 order-2 order-lg-1">
                        <h1>Рассмотрение абстракций и их взаимодействия библиотек встраиваемых БД<a id="рассмотрение-абстракций-и-их-взаимодействия-библиотек-встраиваемых-бд"></a></h1>
<p><img src="files/main-section.png" alt="main-section"></p>
<p>Часто возникает желание иметь простейшую архитектуру сервиса или программы, в которой будут отсутствовать избыточные компоненты и межсетевое взаимодействие. Это ощутимо сокращает силы и время на их реализацию и поддержку. Чтобы придерживаться такого подхода нужно уметь подбирать <strong>подходящие решения</strong>: технологии, библиотеки, программное обеспечение и т.д.</p>
<p>Подбор может быть достаточно прямолинейным - формирование списка подходящих решений по их применяемой области , но, очевидно, что такой список окажется слишком большим и перенасыщенным. Сегодня век информации и потому <u>её объём вокруг нас огромен, который человек физически не способен усвоить даже за всю жизнь</u>. Осознание этой проблемы объема естесвенным образом приводит к формированию интеллектуального подхода - применения ряда <strong>аналитических практик</strong>, приводящих к сокращению кол-ва информации, способной быть усвоенной человеком в сроки, соответствующие решаемой задачи, и сохранению уровня её качества, релевантности. Т.е. <u>подход, сокращающий список подходящих решений без погружения в исходной код до приемлимого и, в конечном итоге, одного решения</u>.</p>
<p>В данной статье применяется ряд таких практик, на примере подбора библиотек встраиваемых БД. Как таковая решаемая задача отсутствует, потому нет необходимости придти к выбору одной из них.</p>
<p>Пару слов о <strong>встраиваемых БД</strong>: при реализации эксперементальных программ удобно иметь файл с подходящей структурой данных для их сохранения и наличия к нему программного интерфейса базовых операций CRUD, поиска, возможно индексации. Приложение практик к ним прольет больше света на выбор оптимального хранения, оперирования данными в описанном случае.</p>
<h2>Цели<a id="цели"></a></h2>
<ul>
<li>Сформировать список библиотек встраиваемых БД для рассмотрения.</li>
<li>Сформировать список аналитических практик.</li>
<li>Определить вспомогательные инструменты по анализу исходного кода библиотек, лежащих в основе практик.</li>
<li>Применить каждую практику отдельно по каждой БД из списка, описав преимущества и недостатки.</li>
</ul>
<h2>Список БД<a id="список-бд"></a></h2>
<p>В список можно внести огромное кол-во разных вариаций бибиотек, как упоминалось ранее, но мы сократим его до таковых, которые могут быть использованы на практике в будущем(тут конечно каждый сам для себя должен представить, что именно может быть ему полезным, на чем он специализирется или к чему хотел бы приблизиться в своей деятельности). В таких вопросах стоит прислушаться к интуиции.</p>
<p>Помимо прочего, библиотеки должны быть написаны на чистом питоне для чтения исходного кода и техничской возможности анализа вспомогательными инструментами. Основной источник для поиска - Github.</p>
<ul>
<li><a href="https://dataset.readthedocs.io/en/latest/">dataset</a></li>
<li><a href="https://tinydb.readthedocs.io/en/latest/">tinydb</a></li>
<li><a href="https://github.com/RaRe-Technologies/sqlitedict">sqlitedict</a></li>
<li><a href="https://docs.peewee-orm.com/en/latest/peewee/playhouse.html#kv">peewee-kv</a></li>
<li><a href="https://docs.peewee-orm.com/en/latest/peewee/playhouse.html#dataset">peewee-dataset</a></li>
</ul>
<h2>Список практик<a id="список-практик"></a></h2>
<p>Приведем их список, применяемых для получения информации по каждой из библиотек, дающей как бы взгляд со стороны на сложность их внутреннего устройства без погружения в исходный код. Перечисление практик идет в порядке от общего к частному, т.е. самая первая описывает общую картину  наименьшим кол-вом деталей и степенью погружения, при этом больше всех затрагивает высокоуровневые асбтракции, на которых бибилотеки базируются:</p>
<ul>
<li>Построение графа зависимостей модулей.</li>
<li>Построение диаграммы  классов.</li>
<li>Вычисление цикломатической сложности.</li>
<li>Построение графа вызовов базового исполняемого сценария и упрощенной диаграммы их последовательности. Эта практика более близка к реальному использованию библиотеки, т.к. содержит ряд её вызовов, выполнямых повседневно в реальной работе:
<ul>
<li>Создание БД.</li>
<li>Запись данных.</li>
<li>Обновление данных.</li>
<li>Получение, поиск данных.</li>
</ul>
</li>
</ul>
<p>Далееа вот сопровождающее описание будет частным и самым ценным в проделанной работе.</p>
<h2>Вспомогательные инструменты<a id="вспомогательные-инструменты"></a></h2>
<p>Перечисление инструментов с общим описанием по каждому, чтобы в дальнейшем было понятно, для чего мы их используем и что от них ожидается.</p>
<p>Ресурс, содержащий поддерживаемый <a href="https://github.com/analysis-tools-dev/static-analysis#python">список инструментов</a> , по всевозможному анализу кода.</p>
<h3>Pyreverse<a id="pyreverse"></a></h3>
<p><a href="https://www.logilab.org/blogentry/6883">https://www.logilab.org/blogentry/6883</a>
<a href="https://pylint.org/">https://pylint.org/</a></p>
<blockquote>
<p>Pyreverse analyses Python code and extracts UML class diagrams and package depenndencies.</p>
</blockquote>
<p>Утилита является частью пакета <strong>pylint</strong>. Как видно из цитаты, помогает автоматически построить диаграммы классов и импортируемых зависимостей. Со второго мы в дальнейшем и будем начинать рассмотрение, т.к. оно является построением наиболее широкой картины того, как БД программно описана, какие верхнеуровневые компоненты содержит и как они взаимосвязаны.</p>
<p>Построене диаграмм классов даст нам уже более полное видение абстракций, которые содержит БД, и их взаимодействия между собой. При этом утилита позволяет указывать уровень глубины сканирования исходного кода БД.</p>
<h3>Pycallgraph<a id="pycallgraph"></a></h3>
<p><a href="https://pycallgraph.readthedocs.io/en/master/">https://pycallgraph.readthedocs.io/en/master/</a></p>
<p>Понятная альтернатива pyreverse. Строит граф вызовов указанного <strong>исполняемого сценария</strong>, поэтому необходимо в нем иметь вызовы, покрывающие по нисходящей(от высокоуровневых выовов к низкоуровневым) наибольшую часть абстракций библиотеки.</p>
<h3>UML Sequence diagram<a id="uml-sequence-diagram"></a></h3>
<blockquote>
</blockquote>
<h3>Prospector<a id="prospector"></a></h3>
<p><a href="https://github.com/PyCQA/prospector">https://github.com/PyCQA/prospector</a></p>
<p>Некий аггрегатор анализирующих инструментов. Может дать информацию сразу по многим аспектом. Теоретически выявляет места, на которые сразу стоит обратить внимание.</p>
<p>Полезно использовать при сравнении полученной информации по множеству библиотек в случае подбора более подходящей под решение.</p>
<h3>Pylama<a id="pylama"></a></h3>
<p><a href="https://github.com/klen/pylama">https://github.com/klen/pylama</a></p>
<p>Альтернатива <a href="#prospector">prospector</a> менее популярная , судя по показателям в Гитхабе.</p>
<h3>Vulture<a id="vulture"></a></h3>
<p><a href="https://github.com/jendrikseipp/vulture">https://github.com/jendrikseipp/vulture</a></p>
<p>Динамический поисковик неиспользуемого кода. Полезно для видения, насколько исходный код бибилиотеки находится в актуальном состоянии, в каких углах запылилась.</p>
<h3>Pydeps<a id="pydeps"></a></h3>
<p><a href="https://github.com/thebjorn/pydeps">https://github.com/thebjorn/pydeps</a>.</p>
<p>Альтернатива использования  <strong>pyreverse</strong> для построения графа зависимостей с генерацией на осное формата <code>.dot</code> программного пакета <a href="http://www.graphviz.org/about/">Graphviz</a>. Изображение графа генерируется разными цветами, логика в этом присутствует, но для нас она значения не имеет, поэтому не стоит обращать на это внимание.</p>
<h3>Radon<a id="radon"></a></h3>
<p><a href="https://radon.readthedocs.io/en/latest/">https://radon.readthedocs.io/en/latest/</a></p>
<h3>McCabe<a id="mccabe"></a></h3>
<p>https://github.com/PyCQA/mccabe</p>
<h2>Рассмотрение<a id="рассмотрение"></a></h2>
<h3>Построение графа зависимостей<a id="построение-графа-зависимостей"></a></h3>
<p>На графах не отображаются модули стандартной бибилиотеки, а только лишь внешние зависимости. Сам сканируемый пакет отображается в именованных прямоугольных рамках, очерчивающих его модули, отображаемые окружностями. Внешние зависимости отображаются в виде изображений папок с их именами.</p>
<p>Такой граф дает хорошее визуальное представление</p>
<h4>Dataset<a id="dataset"></a></h4>
<p><code>pydeps --noshow --cluster --keep-target-cluster --rmprefix pydeps. venv/lib/python3.8/site-packages/dataset</code></p>
<p><img src="files/dataset/deps.png" alt=""></p>
<h4>TinyDB<a id="tinydb"></a></h4>
<p><code>pydeps --noshow --cluster --keep-target-cluster --rmprefix tinydb. venv/lib/python3.8/site-packages/tinydb</code></p>
<p><img src="files/tinydb/deps.png" alt=""></p>
<h4>Sqlitedict<a id="sqlitedict"></a></h4>
<p><img src="files/sqlitedict/deps.png" alt=""></p>
<p>Как видно эта библиотека не имеет никаких зависимостей и даже не скомпанована как пакет, все абстракции содержатся в одном модуле в 550 строк кода. Всего 2 абстракции и 1 основная.</p>
<h4>Peewee-kv, peewe-dataset<a id="peewee-kv,-peewe-dataset"></a></h4>
<p>По факту это два модуля пакета <code>playhouse</code> функционал которых реализован на основе библиотеки <strong>peewee</strong>, поэтому они рассматриваются вместе и сканируются единой командой.</p>
<p><code>pydeps --include-missing --max-bacon=1 --noshow --cluster --keep-target-cluster --rmprefix playhouse. -T png -o source-deps.png venv/lib/python3.8/site-packages/playhouse</code></p>
<p>Команда генерирует взаимосвязи модулей из сканируемого пакета которые нас не интересуют. поэтому следующее изображение отредактировано вручную, а вот <a href="files/peewee-kv/source-deps.png">ссылка на исходное</a> для сравнения.</p>
<p><img src="files/peewee-kv/edited-deps.png" alt=""></p>
<p>Как видно <code>kv</code> содержит меньше связей по сравнению с <code>dataset</code>.</p>
<h3>Построение диаграммы классов<a id="построение-диаграммы-классов"></a></h3>
<h3>Построение графа вызовов<a id="построение-графа-вызовов"></a></h3>
<h3>Цикломатическая и прочие сложности<a id="цикломатическая-и-прочие-сложности"></a></h3>
<h3>Заключение<a id="заключение"></a></h3>
<h3>Dataset 1.4.1<a id="dataset-1.4.1"></a></h3>
<p>Надстройка SQLAlchemy, что сразу говорит о многообразии абстракций, состоящих из двух слоёв: <strong>SQLAlchemy ORM, SQLAlchemy Core</strong>.</p>
<p>Сама надстройка объявляет 2 основные абстракции: <strong>Database, Table</strong> описанных в 2х модулях суммарно на 1025 строк
кода, имея, тем самым, низкий порог входа понимания их диаграммы взаимодействия.</p>
<pre><code>prospector --with-tool vulture
</code></pre>
<blockquote>
<p><a href="files/dataset/prospector.txt">Анализ</a> кода.</p>
</blockquote>
<pre><code>from pycallgraph import PyCallGraph
from pycallgraph.output import GraphvizOutput

import dataset


with PyCallGraph(output=GraphvizOutput()):
    db = dataset.connect('sqlite:///:memory:')
    table = db['sometable']
    table.insert(dict(name='John Doe', age=37))
    table.insert(dict(name='Jane Doe', age=34, gender='female'))
    john = table.find_one(name='John Doe')
</code></pre>
<blockquote>
<p><a href="files/dataset/pycallgraph.png">Граф</a> вызовов. Содержит очень большой набор вызовов и множества модулей.</p>
</blockquote>
<pre><code>pyreverse  -AS -f ALL -o png  venv/lib/python3.7/site-packages/dataset
</code></pre>
<blockquote>
<p>Полученная <a href="files/dataset/classes.png">диаграмма классов</a>. Очень громоздкая диаграмма с большим кол-вом классов и взаимосвязей. Сказывается базирование на sqlalchemy.</p>
<p><a href="files/dataset/packages.png">Диаграмма связей модулей</a>.</p>
</blockquote>
<h3>TinyDB 4.3.0<a id="tinydb-4.3.0"></a></h3>
<pre><code>prospector --with-tool vulture
</code></pre>
<blockquote>
<p><a href="files/tinydb/prospector.txt">Анализ</a> кода.</p>
</blockquote>
<pre><code>from pycallgraph import PyCallGraph
from pycallgraph.output import GraphvizOutput

from tinydb import TinyDB, Query
from tinydb.storages import MemoryStorage


with PyCallGraph(output=GraphvizOutput()):
    db = TinyDB(storage=MemoryStorage)
    User = Query()
    db.insert({'name': 'John', 'age': 22})
    db.insert({'name': 'Van', 'car': 'volvo'})
    db.search(User.name == 'Van')
</code></pre>
<blockquote>
<p><a href="files/tinydb/pycallgraph.png">Граф</a> вызовов. Содержит крошечный набор вызовов.</p>
</blockquote>
<pre><code>pyreverse  -AS -f ALL -o png  venv/lib/python3.7/site-packages/tinydb
</code></pre>
<blockquote>
<p>Полученная <a href="files/tinydb/classes.png">диаграмма классов</a>.</p>
<p><a href="files/tinydb/packages.png">Диаграмма связей модулей</a>.</p>
</blockquote>
<h3>Sqlitedict 1.7.0<a id="sqlitedict-1.7.0"></a></h3>
<ul>
<li>
<p>Минимализм, выраженный 1м модулем из 550 строк кода.</p>
</li>
<li>
<p>Всего <u>2 абстракции и 1 основная</u>, т.е. для взаимодействия с данными используется <strong>SqliteDict</strong>, предоставляющий  соответствующий интерфейс, который обращается к кастомному <strong>SqliteMultithread</strong>. Этот объект уже напрямую выполняет операции в БД.</p>
<p><img src="files/sqlitedict/basic-sequence.png" alt="basic-sequence"></p>
</li>
<li>
<p>На уровне БД схема таблиц(они же словари) организована наипростейшим образом без возможности кастомизации. <strong>Ключ</strong> объявлен строковым, а <strong>значение</strong> бинарным типами. Таким образом на уровне питона <u>неполностью эмулируются возможности словаря</u>.</p>
<pre><code>complex_discount = SqliteDict('db.sqlite')
complex_discount[('pencil', 'case', 'eraser')] = 15

sqlite3.InterfaceError: Error binding parameter 0 - probably unsupported type.
</code></pre>
</li>
<li>
<p>Автогенерируемый <strong>индекс</strong> по ключу.</p>
</li>
<li>
<p>Поддержка кастомной сериализации значений</p>
<pre><code>rss = SqliteDict('db.sqlite', encode=xml_encode, decode=xml_decode)
</code></pre>
</li>
<li>
<p>Поддержка многопоточности.</p>
<p>Следует отметить, что в данной реализации объект-словарь необходимо разделять между потоками.</p>
<pre><code>def job(job_results):
	k, v = fetch()
	job_results[k] = v

job_results = SqliteDict('db.sqlite')

t1 = Thread(target=job, args=(job_results, ))
t2 = Thread(target=job, args=(job_results, ))
</code></pre>
</li>
<li>
<p>Зачем-то оставлен режим создания БД в памяти <code>:memory:</code>. Было бы логичным его убрать для позиционируемой персистентности  словаря.</p>
</li>
<li>
<p>Хороший кандидат для быстрого старта и фокусировки на логике работы с данными, но остается неясность в том, как будет вести себя объект-словарь при различных вариациях параметров <code>autocommit, journal_mode</code>.</p>
</li>
</ul>
<h2>Результаты применения общей практики.<a id="результаты-применения-общей-практики."></a></h2>
<h3>Dataset.<a id="dataset."></a></h3>
<h4>Диаграммы.<a id="диаграммы."></a></h4>
<p><img src="files/dataset/packages.png" alt="packages"></p>
<p><img src="files/dataset/classes.png" alt="classes"></p>
<h3>TinyDB.<a id="tinydb."></a></h3>
<p><img src="files/tinydb/packages.png" alt="packages"></p>
<p><img src="files/tinydb/classes.png" alt="classes"></p>
<h3>Sqlitedict<a id="sqlitedict"></a></h3>
<p><img src="files/sqlitedict/classes.png" alt="classes"></p>

        </div>
        <div id="toc" class="col-lg-3 order-1 order-lg-2">
            <ul><li><a href="#цели">Цели</a></li><li><a href="#список-бд">Список БД</a></li><li><a href="#список-практик">Список практик</a></li><li><a href="#вспомогательные-инструменты">Вспомогательные инструменты</a><ul><li><a href="#pyreverse">Pyreverse</a></li><li><a href="#pycallgraph">Pycallgraph</a></li><li><a href="#uml-sequence-diagram">UML Sequence diagram</a></li><li><a href="#prospector">Prospector</a></li><li><a href="#pylama">Pylama</a></li><li><a href="#vulture">Vulture</a></li><li><a href="#pydeps">Pydeps</a></li><li><a href="#radon">Radon</a></li><li><a href="#mccabe">McCabe</a></li></ul></li><li><a href="#рассмотрение">Рассмотрение</a><ul><li><a href="#построение-графа-зависимостей">Построение графа зависимостей</a><ul><li><a href="#dataset">Dataset</a></li><li><a href="#tinydb">TinyDB</a></li><li><a href="#sqlitedict">Sqlitedict</a></li><li><a href="#peewee-kv,-peewe-dataset">Peewee-kv, peewe-dataset</a></li></ul></li><li><a href="#построение-диаграммы-классов">Построение диаграммы классов</a></li><li><a href="#построение-графа-вызовов">Построение графа вызовов</a></li><li><a href="#цикломатическая-и-прочие-сложности">Цикломатическая и прочие сложности</a></li><li><a href="#заключение">Заключение</a></li><li><a href="#dataset-1.4.1">Dataset 1.4.1</a></li><li><a href="#tinydb-4.3.0">TinyDB 4.3.0</a></li><li><a href="#sqlitedict-1.7.0">Sqlitedict 1.7.0</a></li></ul></li><li><a href="#результаты-применения-общей-практики.">Результаты применения общей практики.</a><ul><li><a href="#dataset.">Dataset.</a><ul><li><a href="#диаграммы.">Диаграммы.</a></li></ul></li><li><a href="#tinydb.">TinyDB.</a></li><li><a href="#sqlitedict">Sqlitedict</a></li></ul></li></ul>
        </div>
    </div>
    <div class="row">
    <div id="comments" class="col-lg-9">
        <script src="https://utteranc.es/client.js"
                repo="4l1fe/4l1fe.github.io"
                issue-term="pathname"
                label="comment"
                theme="github-light"
                crossorigin="anonymous"
                async>
        </script>
    </div>
</div>
</div>

<script src="https://buttons.github.io/buttons.js"></script>
</body>
</html>