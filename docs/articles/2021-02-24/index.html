<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="utO5yk8RwIXZ-_rnxq_xpMndgtw0MU_VqtE61lNmjsY" />
    <link rel="icon" type="image/png" href="/files/favicon.png">
    <link rel="alternate" type="application/rss+xml" href="/rss.xml">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css"
          rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl"
          crossorigin="anonymous">
    <link rel="stylesheet" href="/files/css/style.css">
    <script src="https://code.iconify.design/1/1.0.7/iconify.min.js"></script>
    <title>ТехнологоблогЪ</title>
</head>
<body>
<nav class="navbar navbar-light bg-white border-bottom border-secondary sticky-top mb-1">
    <div class="container-fluid d-flex justify-content-center ">
            <a class="navbar-brand fs-3" href="/">Технологоблог<b>Ъ</b></a>
            <span class="mx-2"><a class="github-button mx-2" href="https://github.com/4l1fe/4l1fe.github.io/subscription" data-icon="octicon-eye" data-size="large" 
data-show-count="true" aria-label="Watch 4l1fe/4l1fe.github.io on GitHub">Watch</a></span>
            <span class="mx-2"><a class="github-button mx-2" href="https://github.com/4l1fe/4l1fe.github.io" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star 4l1fe/4l1fe.github.io on GitHub">Star</a></span>
    </div>
</nav>
<div class="container">
        <div class="row">
        <div id="content" class="col-lg-9 order-2 order-lg-1">
            <h1>Рассмотрение абстракций, их взаимосвязей и сложности библиотек встраиваемых БД <a id="рассмотрение-абстракций,-их-взаимосвязей-и-сложности-библиотек-встраиваемых-бд" href="#%D1%80%D0%B0%D1%81%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B9,-%D0%B8%D1%85-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%B5%D0%B9-%D0%B8-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA-%D0%B2%D1%81%D1%82%D1%80%D0%B0%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D1%85-%D0%B1%D0%B4"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h1>
<p><img src="files/main-section.png" alt="main-section"></p>
<p>Часто возникает желание иметь простейшую архитектуру сервиса или программы, в которой будут отсутствовать избыточные компоненты и межсетевое взаимодействие. Это ощутимо сокращает силы и время на их реализацию, поддержку и погружение. Чтобы придерживаться такого подхода нужно уметь подбирать <strong>подходящие технологии и библиотеки</strong>.</p>
<p>Подбор может быть достаточно прямолинейным - формирование списка подходящих решений по их применяемой области, но, очевидно, что такой список окажется слишком большим и перенасыщенным. Сегодня век информации и потому её объём вокруг нас огромен, который человек физически не способен усвоить даже за всю жизнь, да-да представь себе. Осознание этой проблемы объема естесвенным образом приводит к формированию интеллектуального подхода - применения ряда <strong>аналитических практик</strong>, приводящих к сокращению кол-ва информации, способной быть усвоенной человеком в сроки, соответствующие решаемой задачи, и сохранению уровня её качества, релевантности. Т.е. подход, сокращающий список подходящих решений без погружения в исходной код до приемлимого и, в конечном итоге, одного.</p>
<p>В данной статье применяется ряд таких практик, на примере подбора библиотек встраиваемых БД. Как таковая решаемая задача отсутствует, потому необходимости придти к выбору одной из них нету.</p>
<h2>Цели <a id="цели" href="#%D1%86%D0%B5%D0%BB%D0%B8"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h2>
<ul>
<li>Сформировать список библиотек встраиваемых БД к рассмотрению.</li>
<li>Сформировать список аналитических практик.</li>
<li>Определить инструменты по анализу исходного кода библиотек, лежащих в основе практик.</li>
<li>Применить каждую практику отдельно по каждой БД из списка, описав полученные результаты.</li>
</ul>
<h2>Список БД <a id="список-бд" href="#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B1%D0%B4"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h2>
<p>В список можно внести огромное кол-во разных вариаций библиотек, как упоминалось ранее, но мы сократим его до таковых, которые могут быть использованы на практике в будущем(тут конечно каждый сам для себя должен представить, что именно может быть ему полезным, на чем он специализируется или к чему хотел бы приблизиться в своей деятельности).</p>
<p>Помимо прочего, библиотеки должны быть написаны на чистом питоне для чтения исходного кода и технической возможности анализа вспомогательными инструментами. Основной источник для поиска - <strong>Github</strong>.</p>
<p>Возьмем за кол-во три библиотеки, как минимально показательное, учитывая, что полученной информации по ним будет в конечном итоге много.</p>
<ul>
<li><a href="https://tinydb.readthedocs.io/en/latest/"><span class="iconify" data-icon="bx:bx-link-external"></span> tinydb</a></li>
<li><a href="https://github.com/RaRe-Technologies/sqlitedict"><span class="iconify" data-icon="codicon:github-inverted"></span> sqlitedict</a></li>
<li><a href="https://docs.peewee-orm.com/en/latest/peewee/playhouse.html#kv"><span class="iconify" data-icon="bx:bx-link-external"></span> peewee-kv</a></li>
</ul>
<h2>Список практик <a id="список-практик" href="#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h2>
<p>Приведем их список, применяемых для получения информации по каждой из библиотек, дающей как бы взгляд сверху на абстрактную сложность их внутреннего устройства без погружения в исходный код.</p>
<p>Перечисление практик идет в порядке от общего к частному, т.е. самая первая описывает общую картину с наименьшим кол-вом деталей и степенью погружения, при этом больше всех затрагивает высокоуровневые абстракции, на которых библиотеки базируются:</p>
<ul>
<li>Построение графа зависимостей модулей.</li>
<li>Построение диаграммы  классов.</li>
<li>Построение графа вызовов базового <strong>исполняемого сценария</strong>. Эта практика наиболее близка к реальной эксплуатации библиотеки, т.к. содержит ряд её вызовов, без которых выполнямая повседневно реальная работа бессмыслена:
<ul>
<li>Создание БД.</li>
<li>Запись данных.</li>
<li>Обновление данных.</li>
<li>Получение, поиск данных.</li>
<li>Удаление записи.</li>
</ul>
</li>
<li>Построение графика цикломатической сложности.</li>
<li>Построение графика halstead-измерений и суммарных характеристик. Суммарные характеристики - взятые из предыдущих практик в дополнение к halstead-измерениям.</li>
</ul>
<h2>Вспомогательные инструменты <a id="вспомогательные-инструменты" href="#%D0%B2%D1%81%D0%BF%D0%BE%D0%BC%D0%BE%D0%B3%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h2>
<p>Перечислим инструменты с кратким описанием по каждому, чтобы в дальнейшем было понятно, для чего мы их используем и что от них ожидается.</p>
<p>Ресурс, содержащий поддерживаемый <a href="https://github.com/analysis-tools-dev/static-analysis#python"><span class="iconify" data-icon="codicon:github-inverted"></span> список инструментов</a> по всевозможному анализу кода.</p>
<h3>Pyreverse <a id="pyreverse" href="#pyreverse"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p><a href="https://www.logilab.org/blogentry/6883"><span class="iconify" data-icon="bx:bx-link-external"></span> https://www.logilab.org/blogentry/6883</a></p>
<blockquote>
<p>Pyreverse analyses Python code and extracts UML class diagrams and package depenndencies.</p>
</blockquote>
<p>Утилита является частью пакета <a href="https://pylint.org"><span class="iconify" data-icon="bx:bx-link-external"></span> pylint</a>. Как видно из цитаты, автоматически строит диаграммы классов. Эти диаграммы дадут нам  видение абстракций, которые содержит БД, и их взаимосвязей. При этом утилита позволяет указывать уровень глубины сканирования исходного кода.</p>
<h3>Pydeps <a id="pydeps" href="#pydeps"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p><a href="https://github.com/thebjorn/pydeps"><span class="iconify" data-icon="codicon:github-inverted"></span> https://github.com/thebjorn/pydeps</a>.</p>
<p>Утилита построения графа зависимостей с генерацией на осное формата <code>.dot</code> программного пакета <a href="http://www.graphviz.org/about/"><span class="iconify" data-icon="bx:bx-link-external"></span> Graphviz</a>. Изображение графа генерируется разными цветами, логика в этом присутствует, но для нас она значения не имеет, поэтому не стоит обращать на это внимание.</p>
<h3>Gprof2dot <a id="gprof2dot" href="#gprof2dot"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p><a href="https://github.com/jrfonseca/gprof2dot"><span class="iconify" data-icon="codicon:github-inverted"></span> https://github.com/jrfonseca/gprof2dot</a></p>
<p>Утилита строит граф вызовов указанного исполняемого сценария, поэтому необходимо в нем иметь вызовы оптимального кол-ва <strong>базовых абстракций</strong> библиотеки. Строится из файла формата <code>.pstats</code> стандартной библиотеки <a href="https://docs.python.org/3/library/profile.html#the-stats-class"><span class="iconify" data-icon="bx:bx-link-external"></span> Stats</a>. В дополнение к ней нужно иметь предустановленный программный пакет <a href="https://graphviz.org/download/#linux"><span class="iconify" data-icon="bx:bx-link-external"></span> GraphViz</a> и в частности утилиту <code>dot</code>.</p>
<h3>Radon <a id="radon" href="#radon"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p><a href="https://radon.readthedocs.io/en/latest/"><span class="iconify" data-icon="bx:bx-link-external"></span> https://radon.readthedocs.io/en/latest/</a></p>
<p>Утилита сканирует исходный код и выводит показатели следующих измерений:</p>
<ul>
<li>Cyclomatic Complexity (i.e. McCabe’s Complexity)</li>
<li>Halstead metrics</li>
</ul>
<h3>McCabe <a id="mccabe" href="#mccabe"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p><a href="https://github.com/pycqa/mccabe"><span class="iconify" data-icon="codicon:github-inverted"></span> https://github.com/pycqa/mccabe</a></p>
<p>Утилита в дополнение к <strong>radon</strong> генерирует граф в текстовом формате <code>dot</code> по которому можно сгенерировать отображение его прохождения потоком управления.</p>
<h2>Рассмотрение <a id="рассмотрение" href="#%D1%80%D0%B0%D1%81%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D0%BD%D0%B8%D0%B5"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h2>
<h3>Построение графа зависимостей <a id="построение-графа-зависимостей" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B0-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p>На графах не отображаются модули стандартной библиотеки, а только лишь внешние зависимости. Сам сканируемый пакет отображается в именованных прямоугольных рамках, очерчивающих его модули, отображаемые окружностями. Внешние зависимости отображаются в виде изображений папок с их именами.</p>
<p>Такой граф дает визуальное представление полной картины того, как исходный код структурирован, какие верхнеуровневые компоненты содержит и как они взаимосвязаны.</p>
<h4>TinyDB <a id="tinydb" href="#tinydb"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<pre><code>pydeps --noshow --cluster --keep-target-cluster --rmprefix tinydb. -T png -o deps.png venv/lib/python3.8/site-packages/tinydb
</code></pre>
<p><img src="files/tinydb/deps.png" alt=""></p>
<p>Вот первое отображение структуры компонентов из которых собрана библиотека. Слева основной импортируемый модуль, который вбирает функционал остальных, что видно по направленным стрелкам-связям.</p>
<h4>Sqlitedict <a id="sqlitedict" href="#sqlitedict"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<p><img src="files/sqlitedict/deps.png" alt=""></p>
<p>Библиотека не имеет никаких зависимостей и даже не скомпанована как пакет, все абстракции содержатся в одном модуле в 550 строк кода и их всего 2, одна из которых основная, верхнеуровневая. Это сразу знак того, что порог входа по изучению нулевой.</p>
<p>Казалось бы сказать тут нечего, но это косвенно и обозначает преимущество.</p>
<h4>Peewee-kv <a id="peewee-kv" href="#peewee-kv"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<p>Фактически это модуль пакета <code>playhouse</code> который расширением функционала реализованного в библиотеке <strong>peewee</strong>.</p>
<pre><code>pydeps --include-missing --max-bacon=1 --noshow --cluster --keep-target-cluster --rmprefix playhouse. -T png -o source-deps.png venv/lib/python3.8/site-packages/playhouse
</code></pre>
<p>Команда генерирует взаимосвязи модулей из сканируемого пакета которые нас не интересуют. поэтому следующее изображение отредактировано вручную, а вот ссылка на исходное <a href="files/peewee-kv/source-deps.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> source-deps.png</a> для сравнения.</p>
<p><img src="files/peewee-kv/edited-deps.png" alt=""></p>
<p>Наш лидер по сложности из 3х, что впринципе и так понятно, зная о том, что это расширение. Тут мы это просто видим, не погружаясь в код.</p>
<h3>Построение диаграммы классов <a id="построение-диаграммы-классов" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p>В паре секции присутствует ссылка на исходную диаграмму - большое по размеру изображение, включающее все что нужно и нет, и отредактированное изображение базовых абстракций библиотеки, отображающее интересующую нас суть.</p>
<h4>TinyDB <a id="tinydb" href="#tinydb"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<pre><code>pyreverse -o png venv/lib/python3.8/site-packages/tinydb
</code></pre>
<p><img src="files/tinydb/classes.png" alt=""></p>
<p>Достаточно много классов, потому можно предположить, что библиотека предоставляет возможности расширения своими кастомными классами, собственно на это указывают <strong>generalization</strong> связи, например <code>Storage &lt;- MemoryStorage</code>.</p>
<p>Семантичные имена, такие как <code>Middleware, Query, JsonStorage</code>, дают понимание о том что есть некий общий слой обработки, какой-то язык запросов, ну и хранение в конкретном формате <code>json</code>.</p>
<p>Связи у классов <code>Middleware, Query</code> с иными в диаграмме полностью отсутствуют, а значит для их фактического установления необходимо погружаться в код, либо документацию, что уже требует небольших дополнительных усилий, но небольших, потому что библиотека самодостаточно и все содержит в себе.</p>
<h4>Sqlitedict <a id="sqlitedict" href="#sqlitedict"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<pre><code>pyreverse -o png venv/lib/python3.8/site-packages/sqlitedict.py
</code></pre>
<p>Полное отображение <a href="files/sqlitedict/source-classes.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> source-classes.png</a>.</p>
<p><img src="files/sqlitedict/classes.png" alt=""></p>
<p>Выглядит минималистично, прямо сейчас открывай код и читай, нет нужды в чтении документации. Напрямую работа с БД происходит только лишь через <code>SqliteDict</code>, вторая добавляет способность многопоточности и не подразумевает прямых обращений к ней из исполняемого сценария.</p>
<p>Семантика имени <code>SqliteMultithread</code> говорит о способности работы с потоками. Не читая документации мы сразу получили такую информацию о часто интересующем нас вопросе, которую мы не имеем в двух других диаграммах.</p>
<h4>Peewee-kv <a id="peewee-kv" href="#peewee-kv"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<pre><code>pyreverse -o png venv/lib/python3.8/site-packages/playhouse/kv.py
</code></pre>
<p>Полное отображение <a href="files/peewee-kv/source-classes.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> source-classes.png</a>.</p>
<p><img src="files/peewee-kv/classes.png" alt=""></p>
<p>Как и <strong>sqlitedict</strong> имеет минимум абстракций, передающих семантику именами классов и их атрибутов. Не забываем, что изобилие классов исходного кода базовой библиотеки не строилось.</p>
<h3>Построение графа вызовов <a id="построение-графа-вызовов" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B0-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p>Граф базового исполняемого сценария, описанного ранее, будет строиться следующими командами исполненными последовательно для каждого отдельно.</p>
<pre><code>$ python -m cProfile -s nfl -o basic-scenario.pstats basic-scenario.py
$ gprof2dot -f pstats basic-scenario.pstats -o basic-scenario.dot
$ dot -Tpng basic-scenario.dot -o basic-scenario.png
</code></pre>
<p>Код приведенный в каждой секции ниже содержится в <code>basic-scenario.py</code>, который сканируется командами выше. Все вызовы из него должны интуитивно читаться на изображении без каких-либо усилий.</p>
<p>Как и в части диаграмм классов присутствует полное и отредактированное изображения графов.</p>
<h4>TinyDB <a id="tinydb" href="#tinydb"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<pre><code>from tinydb import TinyDB, Query

def main():
    db = TinyDB('test.tinydb')
    table = db.table(TinyDB.default_table_name)
    r1 = table.insert({'name': 'John', 'age': 22})
    r2 = table.insert({'name': 'Van', 'car': 'volvo'})
    User = Query()
    upd = table.update({'car': 'bmw'}, User.age == 22)
    records = table.search(User.name == 'John')
    table.remove(User.name == 'Van')

if __name__ == '__main__':
    main()
</code></pre>
<p>Полный граф <a href="files/tinydb/basic-scenario.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> basic-scenario.png</a></p>
<p><img src="files/tinydb/basic-scenario-edited.png" alt="" title="Call graph"></p>
<p>Видно как операции объекта <code>table</code> обращаются к объекту <code>storage</code> и обращение к нему в свою очередь объекта <code>database</code>. Сценарий очень хорошо читается на самом изображении, вплоть до сброса данных на диск, но сопоставив его с изображением диаграммы классов появляется неясность из-за отсутствия абстракций <code>Middleware, Document, Query</code>. Понятно, что они где-то неявно учавствует(как минимум <code>Document, Query</code>) и логически можно установить это место, но хотелось бы это просто видеть.</p>
<h4>Sqlitedict <a id="sqlitedict" href="#sqlitedict"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<pre><code>from sqlitedict import SqliteDict

def main():
    db = SqliteDict('test.sqlite', autocommit=True)
    db['user1'] = {'name': 'John', 'age': 22}
    db['user2'] = {'name': 'Van', 'car': 'volvo'}
    db['user1']['car'] = 'bmw'
    u = db['user1']
    del db['user2']

if __name__ == '__main__':
    main()
</code></pre>
<p>Полный граф <a href="files/sqlitedict/basic-scenario.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> basic-scenario.png</a></p>
<p><img src="files/sqlitedict/basic-scenario-edited.png" alt=""></p>
<p>Явным концептуальным отличием(логика помимо CRUD операций, создания БД) от предшественника является наличие объекта синхронизации потоков <code>queue</code>, т.к. вообще все вызовы <code>execute</code> производятся классом <code>SqliteMultithread</code>. Это мы знаем из соответстующей диаграммы классов, а благодаря графу еще и видим, где это происходит.</p>
<h4>Peewee-kv <a id="peewee-kv" href="#peewee-kv"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h4>
<pre><code>from playhouse.kv import KeyValue

def main():
    db = KeyValue()
    db['user1'] = {'name': 'John', 'age': 22}
    db['user2'] = {'name': 'Van', 'car': 'volvo'}
    db['user1']['car'] = 'bmw'
    records = db[db.key == 'user1']
    del db['user2']
    
if __name__ == '__main__':
    main()
</code></pre>
<p>Полный граф <a href="files/peewee-kv/basic-scenario.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> basic-scenario.png</a></p>
<p><img src="files/peewee-kv/basic-scenario-edited.png" alt=""></p>
<p>Изображение сразу же демонстрирует большую глубину графа вызовов по сравнению с <strong>tinydb, sqlitedict</strong> и малую степень участия в нем верхнеуровневой абстракции <code>kv</code>, т.е. визуально проявляется степень(она же глубина) участия базовой зависимости - <strong>peewee</strong>.</p>
<p>Отличное раскрывающее дополнение к соответствующим графу зависимостей и диаграмме классов.</p>
<h3>Построение графика цикломатической сложности <a id="построение-графика-цикломатической-сложности" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p>Для нахождения <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity"><span class="iconify" data-icon="bx:bx-link-external"></span> цикломатической сложности</a> воспользуемся утилитой <strong>radon</strong> и произведем нижеследующий вызов для каждой библиотеки отдельно.</p>
<pre><code>radon cc -s --md venv/lib/python3.8/site-packages/tinydb
</code></pre>
<p>Формат <code>md</code> взят для прощей читаемости и дальнейшей обработки полученных данных. Полученные данные <a href="files/tinydb/cc.md"><span class="iconify" data-icon="bi:markdown"></span> tiny.md</a>, <a href="files/sqlitedict/cc.md"><span class="iconify" data-icon="bi:markdown"></span> sqlitedict.md</a>, <a href="files/peewee-kv/cc.md"><span class="iconify" data-icon="bi:markdown"></span> kv.md</a>.</p>
<p>Впринципе, данные таблицы уже показывают нам какая библиотека состоит из большего кол-ва сканируемых классов, методов, функций и число сложности у каждого из них. Этого достаточно, чтобы, опять же, не углубляясь в детали, получить информацию об отличии цикломатических сложностей. Но такое текстовое, табличное представление не настолько наглядно при чтении и сопоставлении одновременно трех таких. Для упрощения этого процесса можно конечно слить все таблицы в один файл и, прокручивая их, сравнивать числовые показатели, аналитически их сопоставляя(что и где больше, насколько хорошо или плохо ли это).</p>
<p>Но для большего удобства восприятия полученных значений мы можем построить график с их цветовой передачей на основе имеющихся табличных файлов с помощью <strong>matplotlib, numpy</strong>. По задумке глубина цвета(темный тон) на графике сразу интуитивно выделит места, требующие внимания.</p>
<p>Код построения графика <a href="files/cc_ranks.py"><span class="iconify" data-icon="teenyicons:python-outline"></span> cc_ranks.py</a> и само изображение.</p>
<p><img src="files/CC-chart.png" alt="" title="Cyclomatic complexity heatmap chart"></p>
<p>Как и было задумано, изображение демонстрирует такие показатели, как объем и глубина цвета и мы видим без аналитического сопоставления, что по объему(количество ячеек) доминирует <strong>tinydb</strong>, а по глубине цвета(наибольшее значение сложности) <strong>sqlitedict</strong>.</p>
<p>Цветовая шкала справа имеет максимальное значение <code>20</code> как максимальную сложность лишь для адаптации к нашему конкретному случаю, в то время как согласно <a href="https://radon.readthedocs.io/en/latest/commandline.html#the-cc-command"><span class="iconify" data-icon="bx:bx-link-external"></span> заявленным категориям</a> оно должно быть <code>41+</code>.</p>
<p>В дополнение мы можем вывести самый сложный метод из <strong>sqlitedict</strong> и построить его граф потока управления следующими командами:</p>
<pre><code>python -m mccabe -d venv/lib/python3.8/site-packages/sqlitedict.py &gt; mccabe.dot
dot -Tpng mccabe.dot -o mccabe.png
</code></pre>
<p>Полученный граф <a href="files/sqlitedict/mccabe.png"><span class="iconify" data-icon="bi:file-earmark-image"></span> mccabe.png</a>, в котором визуально заметен метод <code>SqliteMultithread.run</code> как самый глубокий.</p>
<h3>Построение графика Halstead-измерений и суммарных характеристик <a id="построение-графика-halstead-измерений-и-суммарных-характеристик" href="#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0-halstead-%D0%B8%D0%B7%D0%BC%D0%B5%D1%80%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B8-%D1%81%D1%83%D0%BC%D0%BC%D0%B0%D1%80%D0%BD%D1%8B%D1%85-%D1%85%D0%B0%D1%80%D0%B0%D0%BA%D1%82%D0%B5%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h3>
<p>Для каждой библиотеки получим список <a href="https://en.wikipedia.org/wiki/Halstead_complexity_measures"><span class="iconify" data-icon="bx:bx-link-external"></span> halstead-измерений</a> следующей командой отдельно.</p>
<pre><code>python -m radon hal venv/lib/python3.8/site-packages/sqlitedict.py
</code></pre>
<p>Полученные данные <a href="files/sqlitedict/hal.txt"><span class="iconify" data-icon="bi:file-earmark-text"></span> sqlitedict.txt</a>, <a href="files/peewee-kv/hal.txt"><span class="iconify" data-icon="bi:file-earmark-text"></span> kv.txt</a>, <a href="files/tinydb/hal.txt"><span class="iconify" data-icon="bi:file-earmark-text"></span> tinydb.txt</a> обработаем и возьмем из них только базовые <code>h1, h2, N1, N2</code> которые обозначают: <strong>количество различных операторов, количество различных операндов, количество всех операторов, количество всех операндов</strong> соответственно. Вычисляемые измерения брать не будем, они имеют сомнительный смысл, к тому же их значения достаточно велики, что искажает значимость базовых при их совместном отображении.</p>
<p>Добавим суммарные характеристики <code>Dependencies, Classes count, Graph calls, CC targets count, CC max complexity</code> из ранее полученных результатов рассмотрения. Для этого их надо посчитать вручную.</p>
<p>Пожалуй надо учесть особенность библиотеки <strong>peewee-kv</strong>, что она базируется но мощном ОРМ, и ввести только для неё дополнительный коэфициент, который равен его вероятной сложности, и умножить на него значения всех имеющихся измерений. Для полученных отмасштабированных данных добавим второй график, в котором данные по <strong>sqlitedict, tinydb</strong> будут идентичны первому, тем самым это приблизит наше видение к действительной сложности <strong>peewee-kv</strong>.</p>
<p>Коэффициент вычислим упрощенным способом, вычислив его из суммарного количества строк исходного кода ОРМ и его расширения, допуская, что рост всех значений измерений пропорционален росту кол-ва строк кода. Итого <code>7747 / 173 = 44.78</code>, коэфициент получается слишком большой. Сократим число до одного порядка, т.к. точное значение знать ненужно, важен лишь факт, что оно значительно больше <code>1</code>, т.е. коэфициент равен числу <code>10</code>.</p>
<p>Код преобразования полученных данных halstead-измерений и построения графика <a href="files/hal.py"><span class="iconify" data-icon="teenyicons:python-outline"></span> hal.py</a>, <a href="files/radar.py"><span class="iconify" data-icon="teenyicons:python-outline"></span> radar.py</a>.</p>
<p><img src="files/summary-chart.png" alt="" title="Summary characteristics radar chart"></p>
<p>Формы всех зон покрытия на верхнем графике имеют схожие очертания, иными словами аномальные отличия отсутствуют по каким-либо измерениям, что можно интерпретировать как относительно равную простоту библиотек <strong>sqlitedict, tinydb</strong>. Однако по двум значениям синяя зона наиболее отдалена от красной: <code>h1, CC targets count</code>.</p>
<p>Для <strong>peewee-kv</strong> идея масштабирования доп. коэфициентом сразу отобразила, что в действительности библиотека является намного сложнее остальных, т.к. зона покрытия желтым цветом на нижнем графике резко расширилась по сравнению с первым и охватила остальные зоны, при этом она была наименьшая на верхнем.</p>
<h2>Заключение <a id="заключение" href="#%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5"><span class="iconify" data-icon="majesticons:hashtag-line"></span></a></h2>
<p>Подведем итоги. Просмотрим быстрым взглядом <a href="#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA"><span class="iconify" data-icon="majesticons:hashtag-line"></span> по заявленному порядку</a> все произведенные действия и их результаты. Как и подразумевалось, мы получили достаточно информации об устройстве рассматриваемых объектов для того, чтобы сделать о нем какие-либо выводы. Например, для меня диаграммы зависимостей и классов являются самыми показательными и, при необходимости брать наипростейший вариант, выбрал бы <strong>sqlitedict</strong>, а в случае необходимости кастомизации операций и хранения данных - <strong>peewee-kv</strong>, который оказался наисложнейшим из перечисленных при взятии во внимание его фундамента.</p>
<p>Вообщем, мы не делаем тут выбор, к определенным требованиям свой подходящий кандидат.</p>

        </div>
        <div id="toc" class="col-lg-3 order-1 order-lg-2">
            <ol><li><a href="#цели">Цели</a></li><li><a href="#список-бд">Список БД</a></li><li><a href="#список-практик">Список практик</a></li><li><a href="#вспомогательные-инструменты">Вспомогательные инструменты</a><ol><li><a href="#pyreverse">Pyreverse</a></li><li><a href="#pydeps">Pydeps</a></li><li><a href="#gprof2dot">Gprof2dot</a></li><li><a href="#radon">Radon</a></li><li><a href="#mccabe">McCabe</a></li></ol></li><li><a href="#рассмотрение">Рассмотрение</a><ol><li><a href="#построение-графа-зависимостей">Построение графа зависимостей</a></li><li><a href="#построение-диаграммы-классов">Построение диаграммы классов</a></li><li><a href="#построение-графа-вызовов">Построение графа вызовов</a></li><li><a href="#построение-графика-цикломатической-сложности">Построение графика цикломатической сложности</a></li><li><a href="#построение-графика-halstead-измерений-и-суммарных-характеристик">Построение графика Halstead-измерений и суммарных характеристик</a></li></ol></li><li><a href="#заключение">Заключение</a></li></ol>
        </div>
    </div>
    <div class="row">
        <div id="comments" class="col-lg-9">
            <script src="https://utteranc.es/client.js"
                    repo="4l1fe/4l1fe.github.io"
                    issue-term="pathname"
                    label="comment"
                    theme="github-light"
                    crossorigin="anonymous"
                    async>
            </script>
        </div>
    </div>
</div>

<script src="https://buttons.github.io/buttons.js"></script>
</body>
</html>